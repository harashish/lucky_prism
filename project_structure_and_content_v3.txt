





--------------------------------------------------------------------------------

================================================================================
STRUKTURA PLIKÓW PROJEKTU (Filtr: Migracje, admin.py, apps.py, tests.py zignorowane)
================================================================================

. (Root Project Directory)
└── **backend/**
    └── **backend/**
    ├── urls.py
    ├── settings.py
    └── **apps/**
        ├── **challenges/**
        │   ├── models.py
        │   ├── serializers.py
        │   ├── tests.py
        │   ├── urls.py
        │   └── views.py
        ├── **common/**
        │   ├── models.py
        │   ├── serializers.py
        │   ├── tests.py
        │   ├── urls.py
        │   └── views.py
        ├── **gamification/**
        │   ├── **config/**
        │   │   └── xp_config.py
        │   ├── models.py
        │   ├── serializers.py
        │   ├── **services/**
        │   │   ├── level_calculator.py
        │   │   └── xp_calculator.py
        │   ├── tests.py
        │   ├── urls.py
        │   ├── utils.py
        │   └── views.py
        ├── **goals/**
        │   ├── models.py
        │   ├── serializers.py
        │   ├── tests.py
        │   ├── urls.py
        │   └── views.py
        ├── **habits/**
        │   ├── models.py
        │   ├── serializers.py
        │   ├── tests.py
        │   ├── urls.py
        │   └── views.py
        ├── **mood/**
        │   ├── models.py
        │   ├── serializers.py
        │   ├── tests.py
        │   ├── urls.py
        │   └── views.py
        ├── **notes/**
        │   ├── models.py
        │   ├── serializers.py
        │   ├── tests.py
        │   ├── urls.py
        │   └── views.py
        ├── **settings/**
        │   ├── models.py
        │   ├── serializers.py
        │   ├── tests.py
        │   ├── urls.py
        │   └── views.py
        └── **todos/**
            ├── models.py
            ├── serializers.py
            ├── tests.py
            ├── urls.py
            └── views.py
└── **frontend/**
    └── **constants/**
        ├── theme.ts
        └── xpPreview.ts
    └── **components/**
        ├── AppText.tsx
        ├── FloatingButton.tsx
        ├── FormErrorModal.tsx
        ├── ItemDetails.tsx
        ├── ItemHeader.tsx
        ├── NavigationHeader.tsx
        ├── RandomResultCard.tsx
        ├── XPPopup.tsx
        ├── confirmDelete.tsx
        └── **dashboard/**
            ├── BiggestStreak.tsx
            ├── DailyChallengeTile.tsx
            ├── LevelTile.tsx
            ├── RandomGoalTile.tsx
            ├── RandomHabitTile.tsx
            ├── RandomNoteTile.tsx
            ├── RandomTodoTile.tsx
            └── WeeklyChallengeTile.tsx
    └── **features/**
        ├── **challenges/**
        │   ├── ChallengeFormScreen.tsx
        │   ├── ChallengeItem.tsx
        │   └── TagsFormScreen.tsx
        ├── **goals/**
        │   ├── GoalFormScreen.tsx
        │   └── GoalItem.tsx
        ├── **habits/**
        │   ├── HabitFormScreen.tsx
        │   └── HabitItem.tsx
        ├── **mood/**
        │   └── MoodFormScreen.tsx
        ├── **notes/**
        │   └── NoteFormScreen.tsx
        └── **todos/**
            ├── BottomInputBar.tsx
            ├── CategoryFormScreen.tsx
            ├── TodoItem.tsx
            ├── customDifficultyPicker.tsx
            └── editTodoPopup.tsx
    └── **app/**
        ├── **(tabs)/**
        │   ├── ChallengesListScreen.tsx
        │   ├── GamificationScreen.tsx
        │   ├── GoalsScreen.tsx
        │   ├── HabitsScreen.tsx
        │   ├── MoodScreen.tsx
        │   ├── RandomHomeScreen.tsx
        │   ├── SettingsScreen.tsx
        │   ├── TodosScreen.tsx
        │   ├── _layout.tsx
        │   └── index.tsx
        ├── _layout.tsx
        ├── addCategory.tsx
        ├── addChallenge.tsx
        ├── addGoal.tsx
        ├── addHabit.tsx
        ├── addMood.tsx
        ├── addNote.tsx
        ├── addTag.tsx
        ├── **api/**
        │   └── apiClient.ts
        ├── **editCategory/**
        │   └── [id].tsx
        ├── **editChallenge/**
        │   └── [id].tsx
        ├── **editGoal/**
        │   └── [id].tsx
        ├── **editHabit/**
        │   └── [id].tsx
        ├── **editMood/**
        │   └── [id].tsx
        ├── **editNote/**
        │   └── [id].tsx
        ├── **editTag/**
        │   └── [id].tsx
        ├── **random/**
        │   ├── _layout.tsx
        │   ├── **daily/**
        │   │   ├── active.tsx
        │   │   └── index.tsx
        │   ├── result.tsx
        │   ├── spin.tsx
        │   ├── **todo/**
        │   │   └── index.tsx
        │   └── **weekly/**
        │       ├── active.tsx
        │       └── index.tsx
        └── **stores/**
            ├── useChallengeStore.ts
            ├── useGamificationStore.ts
            ├── useGoalStore.ts
            ├── useHabitStore.ts
            ├── useModuleSettingsStore.ts
            ├── useMoodStore.ts
            ├── useNotesStore.ts
            └── useTodoStore.ts
    └── **utils/**
        └── calcXpPreview.ts

--------------------------------------------------------------------------------

================================================================================
ZAWARTOSĆ 127 PLIKÓW
================================================================================


########## START PLIK: backend\backend\urls.py ##########

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path("api/challenges/", include("apps.challenges.urls")),
    path("api/gamification/", include("apps.gamification.urls")),
    path("api/habits/", include("apps.habits.urls")),
    path("api/goals/", include("apps.goals.urls")),
    path("api/notes/", include("apps.notes.urls")),
    path("api/todos/", include("apps.todos.urls")),
    path("api/common/", include("apps.common.urls")),
    path("api/settings/", include("apps.settings.urls")),
    path("api/mood/", include("apps.mood.urls")),
]



########## KONIEC PLIKU: backend\backend\urls.py ##########



########## START PLIK: backend\backend\settings.py ##########

"""
Django settings for backend project.

Generated by 'django-admin startproject' using Django 5.2.8.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-6kyakyhk^0y)jd85+)8@emd+dyxg!bl#n&!&)0w30@w@l*ck*q'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

# ALLOWED_HOSTS = ["10.180.177.57", "localhost", "127.0.0.1"]
ALLOWED_HOSTS = ['*']

# Application definition

REST_FRAMEWORK = {
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
}

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'rest_framework',
    'corsheaders',
    'django_filters',
    'drf_spectacular',

    'apps.challenges',
    'apps.habits',
    'apps.todos',
    'apps.goals',
    'apps.notes',
    'apps.common',
    'apps.gamification',
    'apps.settings',
    'apps.mood',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',

    'corsheaders.middleware.CorsMiddleware',
]

ROOT_URLCONF = 'backend.urls'

CORS_ALLOW_ALL_ORIGINS = True   #na lokalny dev

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'backend.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


########## KONIEC PLIKU: backend\backend\settings.py ##########



########## START PLIK: backend\apps\challenges\models.py ##########

from django.db import models
from django.utils import timezone
from datetime import timedelta
from apps.gamification.services.xp_calculator import calculate_xp

class ChallengeType(models.Model):
    name = models.CharField(
        max_length=10,
        choices=[
            ("daily", "Daily"),
            ("weekly", "Weekly"),
        ],
        unique=True,
    )

    def __str__(self):
        return self.name


class ChallengeTag(models.Model):
    name = models.CharField(max_length=30, unique=True)

    def __str__(self):
        return self.name

class ChallengeDefinition(models.Model):
    title = models.CharField(max_length=70, unique=True)
    description = models.TextField(blank=True)
    difficulty = models.ForeignKey(
        "common.DifficultyType",
        on_delete=models.PROTECT,
    )
    type = models.ForeignKey(
        ChallengeType,
        on_delete=models.PROTECT,
    )
    tags = models.ManyToManyField(ChallengeTag, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.title

class UserChallenge(models.Model):
    user = models.ForeignKey(
        "gamification.User",
        on_delete=models.CASCADE,
        related_name="challenges",
    )
    definition = models.ForeignKey(
        ChallengeDefinition,
        on_delete=models.CASCADE,
    )
    challenge_type = models.ForeignKey(
        ChallengeType,
        on_delete=models.PROTECT,
    )

    start_date = models.DateField(auto_now_add=True)
    weekly_deadline = models.DateField(null=True, blank=True)

    is_completed = models.BooleanField(default=False)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def start_weekly_if_needed(self):
        if self.challenge_type.name == "weekly" and not self.weekly_deadline:
            self.weekly_deadline = self.start_date + timedelta(days=7)
            self.save(update_fields=["weekly_deadline"])

    @property
    def weekly_progress_days(self):
        if self.challenge_type.name != "weekly" or not self.weekly_deadline:
            return None

        today = timezone.now().date()
        days_passed = (today - self.start_date).days + 1

        return max(1, min(7, days_passed))

    def complete(self):
        if self.is_completed:
            return None

        xp = calculate_xp(
            module="challenges",
            difficulty=self.definition.difficulty.name.lower(),
            period=self.challenge_type.name,
            user=self.user,
        )

        self.user.add_xp(
            xp=xp,
            source="challenge",
            source_id=self.id,
        )

        self.is_completed = True
        self.save(update_fields=["is_completed", "updated_at"])

        return xp




########## KONIEC PLIKU: backend\apps\challenges\models.py ##########



########## START PLIK: backend\apps\challenges\serializers.py ##########

from rest_framework import serializers
from .models import (
    ChallengeDefinition,
    ChallengeTag,
    ChallengeType,
    UserChallenge,
)
from apps.common.models import DifficultyType
from apps.common.serializers import DifficultyTypeSerializer

class ChallengeTagSerializer(serializers.ModelSerializer):
    class Meta:
        model = ChallengeTag
        fields = ["id", "name"]

class ChallengeTypeSerializer(serializers.ModelSerializer):
    class Meta:
        model = ChallengeType
        fields = ["id", "name"]
class ChallengeDefinitionSerializer(serializers.ModelSerializer):
    type = ChallengeTypeSerializer(read_only=True)
    difficulty = DifficultyTypeSerializer(read_only=True)
    tags = ChallengeTagSerializer(many=True, read_only=True)

    type_id = serializers.PrimaryKeyRelatedField(
        write_only=True,
        queryset=ChallengeType.objects.all(),
        source="type",
    )
    difficulty_id = serializers.PrimaryKeyRelatedField(
        write_only=True,
        queryset=DifficultyType.objects.all(),
        source="difficulty",
    )
    tags_ids = serializers.PrimaryKeyRelatedField(
        write_only=True,
        many=True,
        queryset=ChallengeTag.objects.all(),
        source="tags",
        required=False,
    )

    class Meta:
        model = ChallengeDefinition
        fields = [
            "id",
            "title",
            "description",
            "difficulty",
            "type",
            "tags",
            "type_id",
            "difficulty_id",
            "tags_ids",
        ]

    def create(self, validated_data):
        tags = validated_data.pop("tags", [])
        instance = ChallengeDefinition.objects.create(**validated_data)
        if tags:
            instance.tags.set(tags)
        return instance

class UserChallengeSerializer(serializers.ModelSerializer):
    challenge = serializers.SerializerMethodField()
    progress_days = serializers.SerializerMethodField()
    challenge_type = serializers.CharField(
        source="challenge_type.name",
        read_only=True,
    )

    class Meta:
        model = UserChallenge
        fields = [
            "id",
            "challenge",
            "challenge_type",
            "start_date",
            "weekly_deadline",
            "progress_days",
            "is_completed",
        ]

    def get_challenge(self, obj):
        return ChallengeDefinitionSerializer(obj.definition).data

    def get_progress_days(self, obj):
        return obj.weekly_progress_days


########## KONIEC PLIKU: backend\apps\challenges\serializers.py ##########



########## START PLIK: backend\apps\challenges\tests.py ##########

from django.test import TestCase
from apps.challenges.models import ChallengeDefinition, ChallengeType, UserChallenge
from apps.common.models import DifficultyType
from apps.gamification.models import User
from rest_framework.test import APIClient


class UserChallengeUnitTests(TestCase):

    def setUp(self):
        self.user = User.objects.create()
        self.diff = DifficultyType.objects.create(name="easy", order=1)
        self.type = ChallengeType.objects.create(name="daily")

        self.definition = ChallengeDefinition.objects.create(
            title="Test challenge",
            difficulty=self.diff,
            type=self.type
        )

    def test_complete_awards_xp_once(self):
        uc = UserChallenge.objects.create(
            user=self.user,
            definition=self.definition,
            challenge_type=self.type
        )

        xp_first = uc.complete()
        xp_second = uc.complete()

        self.assertGreater(xp_first, 0)
        self.assertIsNone(xp_second)

    def test_complete_sets_completed_flag(self):
        uc = UserChallenge.objects.create(
            user=self.user,
            definition=self.definition,
            challenge_type=self.type
        )

        uc.complete()
        uc.refresh_from_db()

        self.assertTrue(uc.is_completed)


class ChallengeIntegrationTests(TestCase):

    def setUp(self):
        self.client = APIClient()
        self.user = User.objects.create()
        self.diff = DifficultyType.objects.create(name="easy", order=1)
        self.type = ChallengeType.objects.create(name="daily")

        self.definition = ChallengeDefinition.objects.create(
            title="Test challenge",
            difficulty=self.diff,
            type=self.type
        )

    def test_complete_challenge_awards_xp(self):
        assign_res = self.client.post(
            "/api/challenges/assign/",
            {"challenge": self.definition.id},
            format="json"
        )
        self.assertIn(assign_res.status_code, [200, 201])

        user_challenge_id = assign_res.data["id"]

        complete_res = self.client.post(
            f"/api/challenges/user-challenges/{user_challenge_id}/complete/",
            format="json"
        )

        self.assertEqual(complete_res.status_code, 200)

        self.user.refresh_from_db()
        self.assertGreater(self.user.total_xp, 0)

########## KONIEC PLIKU: backend\apps\challenges\tests.py ##########



########## START PLIK: backend\apps\challenges\urls.py ##########

from django.urls import path
from .views import (
    ChallengeListCreate,
    ChallengeDetail,
    ChallengeTagListCreate,
    ChallengeTagDetail,
    ChallengeTypeListCreate,
    AssignChallengeView,
    RandomChallengeView,
    ActiveChallengesView,
    CompleteUserChallengeView,
    DiscardUserChallengeView,
)

urlpatterns = [
    path("", ChallengeListCreate.as_view(), name="challenge-list"),
    path("<int:pk>/", ChallengeDetail.as_view(), name="challenge-detail"),

    path("tags/", ChallengeTagListCreate.as_view(), name="challenge-tags"),
    path("tags/<int:pk>/", ChallengeTagDetail.as_view(), name="challenge-tag-detail"),

    path("types/", ChallengeTypeListCreate.as_view(), name="challenge-types"),

    path("assign/", AssignChallengeView.as_view(), name="challenge-assign"),
    path("random/", RandomChallengeView.as_view(), name="challenge-random"),
    path("active/", ActiveChallengesView.as_view(), name="challenge-active"),

    path(
        "user-challenges/<int:pk>/complete/",
        CompleteUserChallengeView.as_view(),
        name="user-challenge-complete",
    ),
    path(
        "user-challenges/<int:pk>/discard/",
        DiscardUserChallengeView.as_view(),
        name="user-challenge-discard",
    ),
]


########## KONIEC PLIKU: backend\apps\challenges\urls.py ##########



########## START PLIK: backend\apps\challenges\views.py ##########

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status, generics
from django.utils import timezone
import random

from .models import (
    ChallengeDefinition,
    UserChallenge,
    ChallengeType,
    ChallengeTag,
)
from .serializers import (
    ChallengeDefinitionSerializer,
    ChallengeTypeSerializer,
    ChallengeTagSerializer,
    UserChallengeSerializer,
)
from apps.gamification.utils import get_user


class ActiveChallengesView(APIView):
    def get(self, request):
        user = get_user()

        daily = UserChallenge.objects.filter(
            user=user,
            is_completed=False,
            challenge_type__name="daily",
        ).first()

        weekly = UserChallenge.objects.filter(
            user=user,
            is_completed=False,
            challenge_type__name="weekly",
        )

        return Response(
            {
                "daily": UserChallengeSerializer(daily).data if daily else None,
                "weekly": UserChallengeSerializer(weekly, many=True).data,
            },
            status=status.HTTP_200_OK,
        )

class AssignChallengeView(APIView):
    def post(self, request):
        user = get_user()
        challenge_id = request.data.get("challenge")

        try:
            definition = ChallengeDefinition.objects.get(pk=challenge_id)
        except ChallengeDefinition.DoesNotExist:
            return Response(
                {"detail": "Challenge not found"},
                status=status.HTTP_404_NOT_FOUND,
            )

        challenge_type = definition.type

        if challenge_type.name == "daily":
            if UserChallenge.objects.filter(
                user=user,
                challenge_type__name="daily",
                is_completed=False,
            ).exists():
                return Response(
                    {"detail": "Active daily challenge already exists"},
                    status=status.HTTP_400_BAD_REQUEST,
                )

        if challenge_type.name == "weekly":
            if UserChallenge.objects.filter(
                user=user,
                challenge_type__name="weekly",
                is_completed=False,
            ).exists():
                return Response(
                    {"detail": "Active weekly challenge already exists"},
                    status=status.HTTP_400_BAD_REQUEST,
                )

        existing = UserChallenge.objects.filter(
            user=user,
            definition=definition,
        ).first()

        if existing and existing.is_completed:
            existing.is_completed = False
            existing.start_date = timezone.now().date()
            existing.weekly_deadline = None
            existing.save(update_fields=["is_completed", "start_date", "weekly_deadline"])

            existing.start_weekly_if_needed()

            return Response(
                UserChallengeSerializer(existing).data,
                status=status.HTTP_200_OK,
            )

        uc = UserChallenge.objects.create(
            user=user,
            definition=definition,
            challenge_type=challenge_type,
        )

        uc.start_weekly_if_needed()

        return Response(
            UserChallengeSerializer(uc).data,
            status=status.HTTP_201_CREATED,
        )


class RandomChallengeView(APIView):
    def get(self, request):
        user = get_user()
        type_name = request.GET.get("type")
        tags = request.GET.get("tags")
        difficulty_id = request.GET.get("difficulty_id")

        qs = ChallengeDefinition.objects.all()

        if type_name:
            qs = qs.filter(type__name__iexact=type_name)

        if tags:
            tag_ids = [int(x) for x in tags.split(",") if x.strip()]
            qs = qs.filter(tags__in=tag_ids).distinct()

        active_defs = UserChallenge.objects.filter(
            user=user,
            is_completed=False,
        ).values_list("definition_id", flat=True)

        qs = qs.exclude(id__in=active_defs)

        if difficulty_id:
            try:
                did = int(difficulty_id)
                qs = qs.filter(difficulty_id=did)
            except ValueError:
                pass
        
            

        if not qs.exists():
            return Response(
                {"error": "no_available"},
                status=status.HTTP_404_NOT_FOUND,
            )

        picked = random.choice(list(qs))
        return Response(
            ChallengeDefinitionSerializer(picked).data,
            status=status.HTTP_200_OK,
        )


class CompleteUserChallengeView(APIView):
    def post(self, request, pk):
        user = get_user()

        try:
            uc = UserChallenge.objects.get(pk=pk, user=user)
        except UserChallenge.DoesNotExist:
            return Response(
                {"detail": "Not found"},
                status=status.HTTP_404_NOT_FOUND,
            )

        xp = uc.complete()

        return Response(
            {
                "xp_gained": xp or 0,
                "total_xp": user.total_xp,
                "current_level": user.current_level,
            },
            status=status.HTTP_200_OK,
        )


class DiscardUserChallengeView(APIView):
    def post(self, request, pk):
        user = get_user()

        try:
            uc = UserChallenge.objects.get(pk=pk, user=user)
        except UserChallenge.DoesNotExist:
            return Response(
                {"detail": "Not found"},
                status=status.HTTP_404_NOT_FOUND,
            )

        uc.is_completed = True
        uc.save(update_fields=["is_completed", "updated_at"])

        return Response({"detail": "discarded"}, status=status.HTTP_200_OK)


class ChallengeListCreate(generics.ListCreateAPIView):
    queryset = ChallengeDefinition.objects.all()
    serializer_class = ChallengeDefinitionSerializer


class ChallengeDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = ChallengeDefinition.objects.all()
    serializer_class = ChallengeDefinitionSerializer


class ChallengeTagListCreate(generics.ListCreateAPIView):
    queryset = ChallengeTag.objects.all()
    serializer_class = ChallengeTagSerializer


class ChallengeTagDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = ChallengeTag.objects.all()
    serializer_class = ChallengeTagSerializer

    def destroy(self, request, *args, **kwargs):
        tag = self.get_object()

        if ChallengeTag.objects.count() <= 1:
            return Response(
                {"detail": "Cannot delete the last remaining tag."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        if ChallengeDefinition.objects.filter(tags=tag).exists():
            return Response(
                {"detail": "Cannot delete a tag assigned to challenges."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        return super().destroy(request, *args, **kwargs)


class ChallengeTypeListCreate(generics.ListCreateAPIView):
    queryset = ChallengeType.objects.all()
    serializer_class = ChallengeTypeSerializer



########## KONIEC PLIKU: backend\apps\challenges\views.py ##########



########## START PLIK: backend\apps\common\models.py ##########

from django.db import models

class DifficultyType(models.Model):
    name = models.CharField(max_length=20, unique=True)
    order = models.PositiveSmallIntegerField()



########## KONIEC PLIKU: backend\apps\common\models.py ##########



########## START PLIK: backend\apps\common\serializers.py ##########

from rest_framework import serializers
from .models import DifficultyType

class DifficultyTypeSerializer(serializers.ModelSerializer):
    class Meta:
        model = DifficultyType
        fields = ['id', 'name', 'order']


        

        

########## KONIEC PLIKU: backend\apps\common\serializers.py ##########



########## START PLIK: backend\apps\common\tests.py ##########

from django.test import TestCase

# Create your tests here.


########## KONIEC PLIKU: backend\apps\common\tests.py ##########



########## START PLIK: backend\apps\common\urls.py ##########

from django.urls import path
from .views import DifficultyTypeList

urlpatterns = [
    path("difficulties/", DifficultyTypeList.as_view(), name="common-difficulties"),
    
]


########## KONIEC PLIKU: backend\apps\common\urls.py ##########



########## START PLIK: backend\apps\common\views.py ##########

from rest_framework import generics
from .models import DifficultyType
from .serializers import DifficultyTypeSerializer

class DifficultyTypeList(generics.ListAPIView):
    queryset = DifficultyType.objects.all().order_by('order')
    serializer_class = DifficultyTypeSerializer




########## KONIEC PLIKU: backend\apps\common\views.py ##########



########## START PLIK: backend\apps\gamification\config\xp_config.py ##########

GLOBAL_XP_MULTIPLIERS = [0.5, 1.0, 1.5, 2.0]
DEFAULT_GLOBAL_XP_MULTIPLIER = 1.0

BASE_XP = {
    "trivial": 0,
    "easy": 10,
    "medium": 20,
    "hard": 50,
}

MODULE_MULTIPLIER = {
    "habits": 1.0,
    "todos": 0.5,
    "challenges": 1.0,
    "goals": 1.5,
    "mood": 0.5,
}

CHALLENGE_PERIOD_MULTIPLIER = {
    "daily": 1.0,
    "weekly": 1.5,
}

GOAL_PERIOD_MULTIPLIER = {
    "weekly": 1.0,
    "monthly": 3.0,
    "yearly": 8.0,
}

BASE_LEVEL_XP = 100


########## KONIEC PLIKU: backend\apps\gamification\config\xp_config.py ##########



########## START PLIK: backend\apps\gamification\models.py ##########

from django.db import models
from apps.gamification.services.level_calculator import calculate_level

class User(models.Model):
    total_xp = models.BigIntegerField(default=0)
    current_level = models.IntegerField(default=1)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    xp_multiplier = models.FloatField(default=1.0)

    def add_xp(self, *, xp: int, source: str, source_id: int | None = None):

        self.total_xp += xp
        self.current_level = calculate_level(self.total_xp)
        self.save(update_fields=["total_xp", "current_level", "updated_at"])

        XPLog.objects.create(
            user=self,
            source=source,
            source_id=source_id,
            xp=xp,
        )

        return {
            "xp_gained": xp,
            "total_xp": self.total_xp,
            "current_level": self.current_level,
        }


class XPLog(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    source = models.CharField(max_length=30)
    source_id = models.IntegerField(null=True, blank=True)
    xp = models.IntegerField()
    created_at = models.DateTimeField(auto_now_add=True)


########## KONIEC PLIKU: backend\apps\gamification\models.py ##########



########## START PLIK: backend\apps\gamification\serializers.py ##########

from rest_framework import serializers
from .models import User, XPLog

class XPLogSerializer(serializers.ModelSerializer):
    class Meta:
        model = XPLog
        fields = ["id", "source", "source_id", "xp", "created_at"]


class UserSerializer(serializers.ModelSerializer):
    logs = XPLogSerializer(many=True, read_only=True, source="xplog_set")

    class Meta:
        model = User
        fields = [
            "id",
            "total_xp",
            "current_level",
            "created_at",
            "updated_at",
            "xp_multiplier",
            "logs",
        ]



########## KONIEC PLIKU: backend\apps\gamification\serializers.py ##########



########## START PLIK: backend\apps\gamification\services\level_calculator.py ##########

from apps.gamification.config.xp_config import BASE_LEVEL_XP

def calculate_level(total_xp: int) -> int:
    level = 1
    xp = total_xp

    while xp >= BASE_LEVEL_XP * level:
        xp -= BASE_LEVEL_XP * level
        level += 1

    return level


########## KONIEC PLIKU: backend\apps\gamification\services\level_calculator.py ##########



########## START PLIK: backend\apps\gamification\services\xp_calculator.py ##########

from apps.gamification.config.xp_config import (
    BASE_XP,
    MODULE_MULTIPLIER,
    CHALLENGE_PERIOD_MULTIPLIER,
    GOAL_PERIOD_MULTIPLIER,
)

def calculate_xp(
    *,
    module: str,
    difficulty: str,
    period: str | None = None,
    user=None,
) -> int:
    
    base_xp = BASE_XP[difficulty]
    xp = base_xp * MODULE_MULTIPLIER[module]

    if module == "challenges":
        if not period:
            raise ValueError("Challenge requires period")
        xp *= CHALLENGE_PERIOD_MULTIPLIER[period]

    if module == "goals":
        if not period:
            raise ValueError("Goal requires period")
        xp *= GOAL_PERIOD_MULTIPLIER[period]

    if user is not None:
        xp *= user.xp_multiplier 

    return int(xp)


########## KONIEC PLIKU: backend\apps\gamification\services\xp_calculator.py ##########



########## START PLIK: backend\apps\gamification\tests.py ##########

from django.test import TestCase
from apps.gamification.services.xp_calculator import calculate_xp
from apps.gamification.services.level_calculator import calculate_level
from apps.gamification.models import User, XPLog


class XPServiceTests(TestCase):

    def test_calculate_xp_easy_returns_positive_value(self):
        xp = calculate_xp(module="habits", difficulty="easy")
        self.assertEqual(xp, 10)

    def test_calculate_xp_medium_greater_than_easy(self):
        xp_easy = calculate_xp(module="habits", difficulty="easy")
        xp_medium = calculate_xp(module="habits", difficulty="medium")
        self.assertEqual(xp_easy, 10)
        self.assertEqual(xp_medium, 20)
    def test_calculate_xp_respects_user_multiplier(self):
        user = User.objects.create(xp_multiplier=2.0)

        xp = calculate_xp(
            module="habits",
            difficulty="easy",
            user=user,
        )

        self.assertEqual(xp, 20)


class LevelCalculationTests(TestCase):

    def test_level_starts_from_one(self):
        self.assertEqual(calculate_level(0), 1)

    def test_level_increases_with_xp(self):
        self.assertGreaterEqual(calculate_level(500), calculate_level(0))


class UserAddXPTests(TestCase):

    def test_add_xp_updates_total_xp_and_level(self):
        user = User.objects.create()
        user.add_xp(xp=50, source="test")
        user.refresh_from_db()

        self.assertEqual(user.total_xp, 50)
        self.assertGreaterEqual(user.current_level, 1)

    def test_add_xp_creates_log(self):
        user = User.objects.create()
        user.add_xp(xp=10, source="test")

        self.assertEqual(XPLog.objects.count(), 1)

    def test_add_zero_xp_does_not_change_total_xp(self):
        user = User.objects.create()
        user.add_xp(xp=0, source="test")
        user.refresh_from_db()

        self.assertEqual(user.total_xp, 0)


########## KONIEC PLIKU: backend\apps\gamification\tests.py ##########



########## START PLIK: backend\apps\gamification\urls.py ##########

from django.urls import path
from .views import CurrentUserView

urlpatterns = [
    path("me/", CurrentUserView.as_view(), name="current-user"),
]


########## KONIEC PLIKU: backend\apps\gamification\urls.py ##########



########## START PLIK: backend\apps\gamification\utils.py ##########

from apps.gamification.models import User

def get_user():
    user = User.objects.first()
    if not user:
        user = User.objects.create()
    return user


########## KONIEC PLIKU: backend\apps\gamification\utils.py ##########



########## START PLIK: backend\apps\gamification\views.py ##########

from rest_framework.views import APIView
from rest_framework.response import Response
from .serializers import UserSerializer
from apps.gamification.utils import get_user

class CurrentUserView(APIView):
    def get(self, request):
        user = get_user()
        return Response(UserSerializer(user).data)

    def patch(self, request):
        user = get_user()
        multiplier = request.data.get("xp_multiplier")

        if multiplier not in [0.5, 1.0, 1.5, 2.0]:
            return Response(
                {"detail": "Invalid multiplier"},
                status=400,
            )

        user.xp_multiplier = multiplier
        user.save(update_fields=["xp_multiplier", "updated_at"])

        return Response(UserSerializer(user).data)



########## KONIEC PLIKU: backend\apps\gamification\views.py ##########



########## START PLIK: backend\apps\goals\models.py ##########

from django.db import models


class GoalPeriod(models.Model):
    name = models.CharField(
        max_length=10,
        choices=[
            ("weekly", "Weekly"),
            ("monthly", "Monthly"),
            ("yearly", "Yearly"),
        ],
        unique=True,
    )


class Goal(models.Model):
    user = models.ForeignKey("gamification.User", on_delete=models.CASCADE)
    title = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    motivation_reason = models.TextField()
    period = models.ForeignKey(GoalPeriod, on_delete=models.PROTECT)
    difficulty = models.ForeignKey("common.DifficultyType", on_delete=models.PROTECT)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_completed = models.BooleanField(default=False)
    completed_at = models.DateTimeField(null=True, blank=True)



########## KONIEC PLIKU: backend\apps\goals\models.py ##########



########## START PLIK: backend\apps\goals\serializers.py ##########

from rest_framework import serializers
from .models import Goal, GoalPeriod
from apps.common.models import DifficultyType
from apps.common.serializers import DifficultyTypeSerializer
from apps.gamification.utils import get_user


class GoalPeriodSerializer(serializers.ModelSerializer):
    class Meta:
        model = GoalPeriod
        fields = ["id", "name"]


class GoalSerializer(serializers.ModelSerializer):
    period = GoalPeriodSerializer(read_only=True)
    difficulty = DifficultyTypeSerializer(read_only=True)

    period_id = serializers.PrimaryKeyRelatedField(
        queryset=GoalPeriod.objects.all(),
        write_only=True,
        source="period",
    )
    difficulty_id = serializers.PrimaryKeyRelatedField(
        queryset=DifficultyType.objects.all(),
        write_only=True,
        source="difficulty",
    )

    motivation_reason = serializers.CharField(allow_blank=False)

    class Meta:
        model = Goal
        fields = [
            "id",
            "title",
            "description",
            "motivation_reason",
            "period",
            "period_id",
            "difficulty",
            "difficulty_id",
            "is_completed",
            "completed_at",
            "created_at",
            "updated_at",
        ]

    def create(self, validated_data):
        validated_data["user"] = get_user()
        return super().create(validated_data)




########## KONIEC PLIKU: backend\apps\goals\serializers.py ##########



########## START PLIK: backend\apps\goals\tests.py ##########

from django.test import TestCase

# Create your tests here.


########## KONIEC PLIKU: backend\apps\goals\tests.py ##########



########## START PLIK: backend\apps\goals\urls.py ##########

from django.urls import path
from .views import (
    GoalListCreate,
    GoalDetail,
    GoalPeriodList,
    CompleteGoalView,
    RandomGoalView,
)

urlpatterns = [
    path("", GoalListCreate.as_view(), name="goals"),
    path("<int:pk>/", GoalDetail.as_view(), name="goal-detail"),
    path("<int:pk>/complete/", CompleteGoalView.as_view(), name="complete-goal"),
    path("periods/", GoalPeriodList.as_view(), name="goal-periods"),
    path("random/", RandomGoalView.as_view(), name="goal-random"),
]


########## KONIEC PLIKU: backend\apps\goals\urls.py ##########



########## START PLIK: backend\apps\goals\views.py ##########

from django.utils import timezone
from apps.gamification.services.xp_calculator import calculate_xp
from rest_framework import generics, status
from rest_framework.views import APIView
from rest_framework.response import Response
import random

from .models import Goal, GoalPeriod
from .serializers import (
    GoalSerializer,
    GoalPeriodSerializer,
)
from apps.gamification.utils import get_user


class GoalListCreate(generics.ListCreateAPIView):
    serializer_class = GoalSerializer

    def get_queryset(self):
        period = self.request.query_params.get("period")
        qs = Goal.objects.filter(user=get_user()).order_by("-created_at")
        if period:
            qs = qs.filter(period__name__iexact=period)
        return qs

    def perform_create(self, serializer):
        serializer.save(user=get_user())


class GoalDetail(generics.RetrieveUpdateDestroyAPIView):
    serializer_class = GoalSerializer

    def get_queryset(self):
        return Goal.objects.filter(user=get_user())
    
class GoalPeriodList(generics.ListAPIView):
    queryset = GoalPeriod.objects.all()
    serializer_class = GoalPeriodSerializer


class CompleteGoalView(APIView):
    def post(self, request, pk):
        try:
            goal = Goal.objects.get(pk=pk, user=get_user())
        except Goal.DoesNotExist:
            return Response(
                {"detail": "Goal not found."},
                status=status.HTTP_404_NOT_FOUND,
            )

        if goal.is_completed:
            return Response(
                {
                    "detail": "Goal already completed",
                    "already_completed": True,
                },
                status=status.HTTP_200_OK,
            )

        xp = calculate_xp(
            module="goals",
            difficulty=goal.difficulty.name.lower(),
            period=goal.period.name.lower(),
            user=goal.user,
        )

        goal.user.add_xp(
            xp=xp,
            source="goal",
            source_id=goal.id,
        )

        goal.is_completed = True
        goal.completed_at = timezone.now()
        goal.save(update_fields=["is_completed", "completed_at", "updated_at"])

        return Response(
            {
                "goal_id": goal.id,
                "xp_gained": xp,
                "total_xp": goal.user.total_xp,
                "current_level": goal.user.current_level,
            },
            status=status.HTTP_200_OK,
        )

class RandomGoalView(APIView):
    def get(self, request):
        period = request.GET.get("period")
        qs = Goal.objects.filter(user=get_user(), is_completed=False)
        if period:
            qs = qs.filter(period__name__iexact=period)

        if not qs.exists():
            return Response(None, status=status.HTTP_200_OK)

        picked = random.choice(list(qs))
        return Response(GoalSerializer(picked).data, status=status.HTTP_200_OK)

########## KONIEC PLIKU: backend\apps\goals\views.py ##########



########## START PLIK: backend\apps\habits\models.py ##########

from django.db import models

class Habit(models.Model):
    user = models.ForeignKey("gamification.User", on_delete=models.CASCADE)
    title = models.CharField(max_length=70)
    description = models.TextField(blank=True)
    motivation_reason = models.TextField()
    color = models.CharField(max_length=20, default="#908bab")
    difficulty = models.ForeignKey("common.DifficultyType", on_delete=models.PROTECT)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["-created_at"]

    def __str__(self):
        return f"{self.title} ({self.user_id})"


class HabitDay(models.Model):
    STATUS_EMPTY = 0
    STATUS_SKIPPED = 1
    STATUS_COMPLETED = 2

    STATUS_CHOICES = [
        (STATUS_EMPTY, "empty"),
        (STATUS_SKIPPED, "skipped"),
        (STATUS_COMPLETED, "completed"),
    ]

    habit = models.ForeignKey(Habit, on_delete=models.CASCADE, related_name="days")
    date = models.DateField()
    status = models.IntegerField(choices=STATUS_CHOICES, default=STATUS_EMPTY)

    xp_awarded = models.BooleanField(default=False)  
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ("habit", "date")
        ordering = ["-date"]

    def __str__(self):
        return f"{self.habit_id} - {self.date} : {self.get_status_display()}"


########## KONIEC PLIKU: backend\apps\habits\models.py ##########



########## START PLIK: backend\apps\habits\serializers.py ##########

from rest_framework import serializers
from .models import Habit, HabitDay
from apps.common.models import DifficultyType
from apps.common.serializers import DifficultyTypeSerializer


class HabitDaySerializer(serializers.ModelSerializer):
    class Meta:
        model = HabitDay
        fields = [
            "id",
            "date",
            "status",
            "xp_awarded",
            "created_at",
            "updated_at",
        ]


class HabitSerializer(serializers.ModelSerializer):
    difficulty = DifficultyTypeSerializer(read_only=True)
    difficulty_id = serializers.PrimaryKeyRelatedField(
        queryset=DifficultyType.objects.all(),
        write_only=True,
        source="difficulty",
    )

    motivation_reason = serializers.CharField(allow_blank=False)

    class Meta:
        model = Habit
        fields = [
            "id",
            "title",
            "description",
            "motivation_reason",
            "color",
            "difficulty",
            "difficulty_id",
            "is_active",
            "created_at",
            "updated_at",
        ]


########## KONIEC PLIKU: backend\apps\habits\serializers.py ##########



########## START PLIK: backend\apps\habits\tests.py ##########

from django.test import TestCase
from rest_framework.test import APIClient
from apps.gamification.models import User
from apps.common.models import DifficultyType
from apps.habits.models import Habit


class HabitIntegrationTests(TestCase):

    def setUp(self):
        self.client = APIClient()
        self.diff = DifficultyType.objects.create(name="easy", order=1)
        self.user = User.objects.create()

    def test_habit_day_completion_awards_xp(self):
        habit = Habit.objects.create(
            user=self.user,
            title="Meditation",
            difficulty=self.diff
        )

        url = f"/api/habits/{habit.id}/toggle-day/"
        res = self.client.post(url, data={}, format="json")
        self.assertEqual(res.status_code, 200)

        self.user.refresh_from_db()
        self.assertGreater(self.user.total_xp, 0)

    def test_habit_day_cannot_award_xp_twice(self):
        habit = Habit.objects.create(
            user=self.user,
            title="Meditation",
            difficulty=self.diff
        )

        url = f"/api/habits/{habit.id}/toggle-day/"

        self.client.post(url, data={}, format="json")
        self.user.refresh_from_db()
        xp_after_first = self.user.total_xp

        self.client.post(url, data={}, format="json")
        self.user.refresh_from_db()

        self.assertEqual(self.user.total_xp, xp_after_first)


########## KONIEC PLIKU: backend\apps\habits\tests.py ##########



########## START PLIK: backend\apps\habits\urls.py ##########

from django.urls import path
from .views import (
    HabitListCreate,
    HabitDetail,
    HabitDayToggleView,
    HabitMonthView,
    HabitStreakView,
    RandomHabitSummaryView,
)


urlpatterns = [
    path("", HabitListCreate.as_view(), name="habits"),
    path("<int:pk>/", HabitDetail.as_view(), name="habit-detail"),
    path("<int:habit_id>/toggle-day/", HabitDayToggleView.as_view(), name="habit-toggle-day"),
    path("month/", HabitMonthView.as_view(), name="habit-month"),
    path("streaks/", HabitStreakView.as_view(), name="habit-streaks"),
    path("random/", RandomHabitSummaryView.as_view(), name="habit-random-summary"),
]

########## KONIEC PLIKU: backend\apps\habits\urls.py ##########



########## START PLIK: backend\apps\habits\views.py ##########

from rest_framework import generics, status
from rest_framework.views import APIView
from rest_framework.response import Response
from django.db import transaction
from datetime import datetime, date
from django.utils import timezone
import calendar
import random

from .models import Habit, HabitDay
from .serializers import HabitSerializer, HabitDaySerializer
from apps.gamification.services.xp_calculator import calculate_xp
from apps.gamification.utils import get_user


class HabitListCreate(generics.ListCreateAPIView):
    serializer_class = HabitSerializer

    def get_queryset(self):
        return Habit.objects.filter(user=get_user(), is_active=True)

    def perform_create(self, serializer):
        serializer.save(user=get_user())


class HabitDetail(generics.RetrieveUpdateDestroyAPIView):
    serializer_class = HabitSerializer

    def get_queryset(self):
        return Habit.objects.filter(user=get_user())


class HabitDayToggleView(APIView):
    def post(self, request, habit_id):
        date_str = request.data.get("date")
        status_val = request.data.get("status")

        if date_str:
            try:
                d = datetime.strptime(date_str, "%Y-%m-%d").date()
            except Exception:
                return Response(
                    {"detail": "Invalid date format"},
                    status=status.HTTP_400_BAD_REQUEST,
                )
        else:
            d = timezone.now().date()

        try:
            habit = Habit.objects.get(pk=habit_id, user=get_user())
        except Habit.DoesNotExist:
            return Response({"detail": "Habit not found"}, status=404)

        with transaction.atomic():
            obj, _ = HabitDay.objects.select_for_update().get_or_create(
                habit=habit,
                date=d,
                defaults={
                    "status": HabitDay.STATUS_EMPTY,
                    "xp_awarded": False,
                },
            )

            xp_added = 0
            already_completed = obj.status == HabitDay.STATUS_COMPLETED and obj.xp_awarded

            if status_val is None:
                if obj.status == HabitDay.STATUS_EMPTY:
                    new_status = HabitDay.STATUS_COMPLETED
                elif obj.status == HabitDay.STATUS_COMPLETED:
                    new_status = HabitDay.STATUS_SKIPPED
                else:
                    new_status = HabitDay.STATUS_EMPTY
            else:
                new_status = int(status_val)

            obj.status = new_status
            obj.save(update_fields=["status", "updated_at"])

            if new_status == HabitDay.STATUS_COMPLETED and not obj.xp_awarded:
                xp_amount = calculate_xp(
                    module="habits",
                    difficulty=habit.difficulty.name.lower(),
                    user=habit.user,
                )

                habit.user.add_xp(
                    xp=xp_amount,
                    source="habit",
                    source_id=obj.id,
                )

                obj.xp_awarded = True
                obj.save(update_fields=["xp_awarded"])
                xp_added = xp_amount

        return Response(
            {
                "day": HabitDaySerializer(obj).data,
                "xp_gained": xp_added,
                "total_xp": habit.user.total_xp,
                "current_level": habit.user.current_level,
                "already_completed": already_completed,
            },
            status=status.HTTP_200_OK,
        )


class HabitMonthView(APIView):
    def get(self, request):
        month_q = request.query_params.get("month")
        today = timezone.now().date()

        if not month_q:
            month_q = f"{today.year}-{today.month:02d}"

        try:
            year, mon = [int(x) for x in month_q.split("-")]
        except Exception:
            return Response(
                {"detail": "Invalid month"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        _, last_day = calendar.monthrange(year, mon)
        first_date = date(year, mon, 1)
        last_date = date(year, mon, last_day)

        habits = Habit.objects.filter(user=get_user(), is_active=True)
        result = []

        for h in habits:
            days_qs = HabitDay.objects.filter(
                habit=h,
                date__range=(first_date, last_date),
            )
            days_map = {hd.date: hd for hd in days_qs}

            days = []
            for day in range(1, last_day + 1):
                d = date(year, mon, day)
                hd = days_map.get(d)
                days.append(
                    {
                        "date": d.isoformat(),
                        "status": hd.status if hd else HabitDay.STATUS_EMPTY,
                        "xp_awarded": hd.xp_awarded if hd else False,
                    }
                )

            habit_data = HabitSerializer(h).data
            habit_data["days"] = days
            result.append(habit_data)

        return Response(
            {
                "habits": result,
                "month": month_q,
                "first_day": first_date.isoformat(),
                "last_day": last_date.isoformat(),
            }
        )


class HabitStreakView(APIView):
    def get(self, request):
        habits = Habit.objects.filter(user=get_user(), is_active=True)

        best = {
            "habit_id": None,
            "title": None,
            "biggest_streak": 0,
            "current_streak": 0,
        }

        for h in habits:
            days = HabitDay.objects.filter(habit=h).order_by("date")

            max_streak = 0
            cur = 0
            last_date = None

            for d in days:
                if d.status == HabitDay.STATUS_COMPLETED:
                    if last_date and (d.date - last_date).days == 1:
                        cur += 1
                    else:
                        cur = 1
                    max_streak = max(max_streak, cur)
                else:
                    cur = 0
                last_date = d.date

            current_streak = 0
            for d in reversed(days):
                if d.status == HabitDay.STATUS_COMPLETED:
                    current_streak += 1
                else:
                    break

            if max_streak > best["biggest_streak"]:
                best.update(
                    {
                        "habit_id": h.id,
                        "title": h.title,
                        "biggest_streak": max_streak,
                        "current_streak": current_streak,
                    }
                )

        return Response(best, status=status.HTTP_200_OK)

class RandomHabitSummaryView(APIView):
    def get(self, request):
        today = timezone.now().date()
        habits = Habit.objects.filter(user=get_user(), is_active=True)
        if not habits.exists():
            return Response(None, status=status.HTTP_200_OK)

        picked = random.choice(list(habits))
        _, last_day = calendar.monthrange(today.year, today.month)
        first_date = date(today.year, today.month, 1)
        last_date = date(today.year, today.month, last_day)

        days_qs = HabitDay.objects.filter(habit=picked, date__range=(first_date, last_date))
        done = days_qs.filter(status=HabitDay.STATUS_COMPLETED).count()

        summary = {
            "id": picked.id,
            "title": picked.title,
            "reason": picked.motivation_reason,
            "done": done,
            "total": last_day,
        }
        return Response(summary, status=status.HTTP_200_OK)

########## KONIEC PLIKU: backend\apps\habits\views.py ##########



########## START PLIK: backend\apps\mood\models.py ##########

from django.db import models
from django.utils import timezone
from apps.gamification.services.xp_calculator import calculate_xp


class MoodEntry(models.Model):
    MOOD_CHOICES = [
        ("great", "Great"),
        ("good", "Good"),
        ("neutral", "Neutral"),
        ("bad", "Bad"),
        ("terrible", "Terrible"),
    ]

    user = models.ForeignKey("gamification.User", on_delete=models.CASCADE)
    mood = models.CharField(max_length=20, choices=MOOD_CHOICES)

    date = models.DateField()
    time = models.TimeField()

    note = models.TextField(blank=True)

    xp_awarded = models.BooleanField(default=False)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ("user", "date")
        ordering = ["-date"]

    def award_xp_if_needed(self):
        if self.xp_awarded:
            return 0

        # logika difficulty
        difficulty = "medium" if self.note.strip() else "easy"

        xp = calculate_xp(
            module="mood",
            difficulty=difficulty,
            user=self.user,
        )

        self.user.add_xp(
            xp=xp,
            source="mood",
            source_id=self.id,
        )

        self.xp_awarded = True
        self.save(update_fields=["xp_awarded"])

        return xp

########## KONIEC PLIKU: backend\apps\mood\models.py ##########



########## START PLIK: backend\apps\mood\serializers.py ##########

from rest_framework import serializers
from .models import MoodEntry
from apps.gamification.utils import get_user
from django.utils import timezone


class MoodEntrySerializer(serializers.ModelSerializer):
    xp_gained = serializers.IntegerField(read_only=True)

    class Meta:
        model = MoodEntry
        fields = [
            "id",
            "mood",
            "date",
            "time",
            "note",
            "xp_gained",
        ]

    def create(self, validated_data):
        validated_data["user"] = get_user()
        instance = super().create(validated_data)

        xp = instance.award_xp_if_needed()
        instance.xp_gained = xp

        return instance

########## KONIEC PLIKU: backend\apps\mood\serializers.py ##########



########## START PLIK: backend\apps\mood\tests.py ##########

from django.test import TestCase

# Create your tests here.


########## KONIEC PLIKU: backend\apps\mood\tests.py ##########



########## START PLIK: backend\apps\mood\urls.py ##########

from django.urls import path
from .views import MoodListCreate, MoodDetail

urlpatterns = [
    path("", MoodListCreate.as_view()),
    path("<int:pk>/", MoodDetail.as_view()),
]

########## KONIEC PLIKU: backend\apps\mood\urls.py ##########



########## START PLIK: backend\apps\mood\views.py ##########

from rest_framework import generics
from .models import MoodEntry
from .serializers import MoodEntrySerializer
from apps.gamification.utils import get_user


class MoodListCreate(generics.ListCreateAPIView):
    serializer_class = MoodEntrySerializer

    def get_queryset(self):
        year = self.request.query_params.get("year")
        qs = MoodEntry.objects.filter(user=get_user())

        if year:
            qs = qs.filter(date__year=year)

        return qs.order_by("date")


class MoodDetail(generics.RetrieveUpdateDestroyAPIView):
    serializer_class = MoodEntrySerializer

    def get_queryset(self):
        return MoodEntry.objects.filter(user=get_user())

########## KONIEC PLIKU: backend\apps\mood\views.py ##########



########## START PLIK: backend\apps\notes\models.py ##########

from django.db import models

class RandomNote(models.Model):
    user = models.ForeignKey("gamification.User", on_delete=models.CASCADE)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    



########## KONIEC PLIKU: backend\apps\notes\models.py ##########



########## START PLIK: backend\apps\notes\serializers.py ##########

from rest_framework import serializers
from .models import RandomNote

class RandomNoteSerializer(serializers.ModelSerializer):
    class Meta:
        model = RandomNote
        fields = ['id', 'content', 'created_at', 'updated_at']


########## KONIEC PLIKU: backend\apps\notes\serializers.py ##########



########## START PLIK: backend\apps\notes\tests.py ##########

from django.test import TestCase

# Create your tests here.


########## KONIEC PLIKU: backend\apps\notes\tests.py ##########



########## START PLIK: backend\apps\notes\urls.py ##########

from django.urls import path
from .views import NotesListCreateView, NoteDetailView, RandomNoteView

urlpatterns = [
    path("", NotesListCreateView.as_view()),
    path("random/", RandomNoteView.as_view()),
    path("<int:pk>/", NoteDetailView.as_view()),
]


########## KONIEC PLIKU: backend\apps\notes\urls.py ##########



########## START PLIK: backend\apps\notes\views.py ##########

from rest_framework import generics, status
from rest_framework.views import APIView
from rest_framework.response import Response
from .models import RandomNote
from .serializers import RandomNoteSerializer
from apps.gamification.utils import get_user
import random

class NotesListCreateView(generics.ListCreateAPIView):
    serializer_class = RandomNoteSerializer

    def get_queryset(self):
        return RandomNote.objects.filter(
            user=get_user()
        ).order_by("-updated_at")

    def perform_create(self, serializer):
        serializer.save(user=get_user())

class NoteDetailView(generics.RetrieveUpdateDestroyAPIView):
    serializer_class = RandomNoteSerializer

    def get_queryset(self):
        return RandomNote.objects.filter(user=get_user())


class RandomNoteView(APIView):
    def get(self, request):
        qs = RandomNote.objects.filter(user=get_user())

        if not qs.exists():
            return Response(None, status=status.HTTP_200_OK)

        note = random.choice(qs)
        return Response(RandomNoteSerializer(note).data)


########## KONIEC PLIKU: backend\apps\notes\views.py ##########



########## START PLIK: backend\apps\settings\models.py ##########

from django.db import models
from apps.gamification.models import User


class ModuleDefinition(models.Model):
    MODULE_CHOICES = [
        ("habits", "Habits"),
        ("challenges", "Challenges"),
        ("todos", "Todos"),
        ("goals", "Goals"),
        ("random", "Random"),
        ("gamification", "Gamification"),
        ("notes", "Notes"),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE)
    module = models.CharField(max_length=30, choices=MODULE_CHOICES)
    is_enabled = models.BooleanField(default=True)

    class Meta:
        unique_together = ("user", "module")

    def __str__(self):
        return f"{self.user_id}:{self.module}:{self.is_enabled}"


class DashboardTile(models.Model):
    TILE_KEYS = [
        ("level_gamification", "Level gamification"),
        ("biggest_streak", "Biggest streak"),
        ("random_habit", "Random habit"),
        ("random_todo", "Random todo"),
        ("goal_week", "Week goal"),
        ("goal_month", "Month goal"),
        ("goal_year", "Year goal"),
        ("daily_challenge", "Daily challenge"),
        ("weekly_challenge", "Weekly challenge"),
        ("random_note", "Random note"),
    ]

    user = models.ForeignKey("gamification.User", on_delete=models.CASCADE)
    key = models.CharField(
    max_length=50,

    choices=TILE_KEYS
    )
    name = models.CharField(max_length=120)
    is_enabled = models.BooleanField(default=True)    
    module_dependency = models.CharField(
    max_length=30,

    choices=ModuleDefinition.MODULE_CHOICES,
    blank=True,
    null=True
)

    class Meta:
        unique_together = ("user", "key")

    def __str__(self):
        return f"{self.user_id}:{self.key}:{self.is_enabled}"

########## KONIEC PLIKU: backend\apps\settings\models.py ##########



########## START PLIK: backend\apps\settings\serializers.py ##########

from rest_framework import serializers
from .models import ModuleDefinition, DashboardTile


class ModuleDefinitionSerializer(serializers.ModelSerializer):
    class Meta:
        model = ModuleDefinition
        fields = ["id", "module", "is_enabled"]


class DashboardTileSerializer(serializers.ModelSerializer):
    class Meta:
        model = DashboardTile
        fields = ["id", "key", "name", "is_enabled", "module_dependency"]
        read_only_fields = ["key", "name", "module_dependency"]

########## KONIEC PLIKU: backend\apps\settings\serializers.py ##########



########## START PLIK: backend\apps\settings\tests.py ##########

from django.test import TestCase

# Create your tests here.


########## KONIEC PLIKU: backend\apps\settings\tests.py ##########



########## START PLIK: backend\apps\settings\urls.py ##########

from django.urls import path
from .views import (
    ModuleDefinitionList,
    ModuleDefinitionUpdate,
    DashboardTileList, 
    DashboardTileUpdate
)
from .views import ExportDataView, ImportDataView

urlpatterns = [
    path("modules/", ModuleDefinitionList.as_view(), name="modules-list"),
    path("dashboard-tiles/", DashboardTileList.as_view(), name="dashboard-tiles"),
    path("dashboard-tiles/<int:pk>/", DashboardTileUpdate.as_view(), name="dashboard-tile-update"),
    path("modules/<int:pk>/", ModuleDefinitionUpdate.as_view(), name="modules-update"),
    path("export/", ExportDataView.as_view(), name="export-data"),
    path("import/", ImportDataView.as_view(), name="import-data"),
]



########## KONIEC PLIKU: backend\apps\settings\urls.py ##########



########## START PLIK: backend\apps\settings\views.py ##########

from rest_framework import generics
from .models import ModuleDefinition, DashboardTile
from .serializers import ModuleDefinitionSerializer, DashboardTileSerializer
from apps.gamification.utils import get_user

class ModuleDefinitionList(generics.ListAPIView):
    serializer_class = ModuleDefinitionSerializer

    def get_queryset(self):
        user = get_user()
        return ModuleDefinition.objects.filter(user=user).order_by("module")

class ModuleDefinitionUpdate(generics.UpdateAPIView):
    queryset = ModuleDefinition.objects.all()
    serializer_class = ModuleDefinitionSerializer

    def perform_update(self, serializer):
        instance = serializer.save()

        DashboardTile.objects.filter(
            user=instance.user,
            module_dependency=instance.module
        ).update(is_enabled=instance.is_enabled)


class DashboardTileList(generics.ListAPIView):
    serializer_class = DashboardTileSerializer

    def get_queryset(self):
        user = get_user()
        return DashboardTile.objects.filter(user=user).order_by("key")


class DashboardTileUpdate(generics.UpdateAPIView):
    queryset = DashboardTile.objects.all()
    serializer_class = DashboardTileSerializer

from django.core import serializers as django_serializers
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.db import transaction
import json

from apps.gamification.models import User, XPLog
from apps.habits.models import Habit, HabitDay
from apps.goals.models import Goal
from apps.challenges.models import (
    ChallengeDefinition,
    ChallengeTag,
    ChallengeType,
    UserChallenge,
)
from apps.todos.models import TodoCategory, TodoTask
from apps.notes.models import RandomNote
from apps.common.models import DifficultyType
from apps.settings.models import ModuleDefinition, DashboardTile
from apps.gamification.utils import get_user

class ExportDataView(APIView):
    def get(self, request):
        user = get_user()

        data = {
            "user": django_serializers.serialize("json", [user]),
            "xp_logs": django_serializers.serialize(
                "json",
                XPLog.objects.filter(user=user),
            ),
            "habits": django_serializers.serialize(
                "json",
                Habit.objects.filter(user=user),
            ),
            "habit_days": django_serializers.serialize(
                "json",
                HabitDay.objects.filter(habit__user=user),
            ),
            "goals": django_serializers.serialize(
                "json",
                Goal.objects.filter(user=user),
            ),
            "challenges_definitions": django_serializers.serialize(
                "json",
                ChallengeDefinition.objects.all(),
            ),
            "challenge_tags": django_serializers.serialize(
                "json",
                ChallengeTag.objects.all(),
            ),
            "challenge_types": django_serializers.serialize(
                "json",
                ChallengeType.objects.all(),
            ),
            "user_challenges": django_serializers.serialize(
                "json",
                UserChallenge.objects.filter(user=user),
            ),
            "todo_categories": django_serializers.serialize(
                "json",
                TodoCategory.objects.all(),
            ),
            "todo_tasks": django_serializers.serialize(
                "json",
                TodoTask.objects.filter(user=user),
            ),
            "notes": django_serializers.serialize(
                "json",
                RandomNote.objects.filter(user=user),
            ),
            "module_settings": django_serializers.serialize(
                "json",
                ModuleDefinition.objects.filter(user=user),
            ),
            "dashboard_tiles": django_serializers.serialize(
                "json",
                DashboardTile.objects.filter(user=user),
            ),
            "difficulties": django_serializers.serialize(
                "json",
                DifficultyType.objects.all(),
            ),
        }

        return Response(data, status=status.HTTP_200_OK)
    
class ImportDataView(APIView):
    def post(self, request):
        payload = request.data

        try:
            with transaction.atomic():
                user = get_user()

                # czyścimy dane usera
                XPLog.objects.filter(user=user).delete()
                Habit.objects.filter(user=user).delete()
                Goal.objects.filter(user=user).delete()
                UserChallenge.objects.filter(user=user).delete()
                TodoTask.objects.filter(user=user).delete()
                RandomNote.objects.filter(user=user).delete()
                ModuleDefinition.objects.filter(user=user).delete()
                DashboardTile.objects.filter(user=user).delete()

                # opcjonalnie reset XP
                user.total_xp = 0
                user.current_level = 1
                user.save()

                # deserialize
                for key, json_data in payload.items():
                    if not json_data:
                        continue
                    objs = django_serializers.deserialize("json", json_data)
                    for obj in objs:
                        obj.save()

        except Exception as e:
            return Response(
                {"detail": str(e)},
                status=status.HTTP_400_BAD_REQUEST,
            )

        return Response({"detail": "Import successful"}, status=200)    

########## KONIEC PLIKU: backend\apps\settings\views.py ##########



########## START PLIK: backend\apps\todos\models.py ##########

from django.db import models

class TodoCategory(models.Model):
    name = models.CharField(max_length=30)
    difficulty = models.ForeignKey("common.DifficultyType", on_delete=models.PROTECT)
    color = models.CharField(max_length=20, blank=True, null=True)

    def __str__(self):
        return f"{self.name}"

class TodoTask(models.Model):
    user = models.ForeignKey("gamification.User", on_delete=models.CASCADE)
    content = models.TextField()
    custom_difficulty = models.ForeignKey(
        "common.DifficultyType",
        on_delete=models.PROTECT,
        null=True,
        blank=True,
    )

    category = models.ForeignKey(
        TodoCategory,
        on_delete=models.PROTECT,
        related_name="tasks",
    )

    is_completed = models.BooleanField(default=False)
    completed_at = models.DateTimeField(null=True, blank=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["-created_at"]

    def __str__(self):
        return self.content[:40]





########## KONIEC PLIKU: backend\apps\todos\models.py ##########



########## START PLIK: backend\apps\todos\serializers.py ##########

from rest_framework import serializers
from .models import TodoCategory, TodoTask
from apps.common.serializers import DifficultyTypeSerializer
from apps.common.models import DifficultyType


class TodoCategorySerializer(serializers.ModelSerializer):
    difficulty = DifficultyTypeSerializer(read_only=True)
    difficulty_id = serializers.PrimaryKeyRelatedField(
        queryset=DifficultyType.objects.all(),
        write_only=True,
        source="difficulty"
    )

    class Meta:
        model = TodoCategory
        fields = ["id", "name", "color", "difficulty", "difficulty_id"]


class TodoTaskSerializer(serializers.ModelSerializer):
    category = TodoCategorySerializer(read_only=True)
    category_id = serializers.PrimaryKeyRelatedField(
        queryset=TodoCategory.objects.all(),
        write_only=True,
        source="category"
    )

    custom_difficulty = DifficultyTypeSerializer(read_only=True)
    custom_difficulty_id = serializers.PrimaryKeyRelatedField(
        queryset=DifficultyType.objects.all(),
        write_only=True,
        source="custom_difficulty",
        required=False,
        allow_null=True
    )

    class Meta:
        model = TodoTask
        fields = [
            "id",
            "content",
            "custom_difficulty",
            "custom_difficulty_id",
            "category",
            "category_id",
            "is_completed",
            "created_at",
            "updated_at",
        ]



########## KONIEC PLIKU: backend\apps\todos\serializers.py ##########



########## START PLIK: backend\apps\todos\tests.py ##########

from django.test import TestCase


########## KONIEC PLIKU: backend\apps\todos\tests.py ##########



########## START PLIK: backend\apps\todos\urls.py ##########

from django.urls import path
from .views import (
    TodoCategoryListCreate, TodoCategoryDetail,
    TodoTaskListCreate, TodoTaskDetail,
    CompleteTodoTaskView, RandomTodoTaskView, CategoryHasUncompletedTasksView
)

urlpatterns = [
    path("categories/", TodoCategoryListCreate.as_view(), name="todo-categories"),
    path("categories/<int:pk>/", TodoCategoryDetail.as_view(), name="todo-category-detail"),
    path("tasks/", TodoTaskListCreate.as_view(), name="todo-tasks"),
    path("tasks/<int:pk>/", TodoTaskDetail.as_view(), name="todo-task-detail"),
    path("tasks/<int:pk>/complete/", CompleteTodoTaskView.as_view(), name="todo-complete"),
    path("tasks/random/", RandomTodoTaskView.as_view(), name="todo-random"),
    path(
    "categories/<int:category_id>/has-uncompleted/",
    CategoryHasUncompletedTasksView.as_view(),
    )
]


########## KONIEC PLIKU: backend\apps\todos\urls.py ##########



########## START PLIK: backend\apps\todos\views.py ##########

from django.utils import timezone
from apps.gamification.services.xp_calculator import calculate_xp
from rest_framework import generics, status
from rest_framework.views import APIView
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
import random

from .models import TodoCategory, TodoTask
from .serializers import (
    TodoCategorySerializer,
    TodoTaskSerializer,
)
from apps.gamification.utils import get_user

class TodoCategoryListCreate(generics.ListCreateAPIView):
    queryset = TodoCategory.objects.all().order_by("name")
    serializer_class = TodoCategorySerializer


class TodoCategoryDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = TodoCategory.objects.all()
    serializer_class = TodoCategorySerializer

    def destroy(self, request, *args, **kwargs):
        category = self.get_object()
        if TodoCategory.objects.count() <= 1:
            return Response(
                {"detail": "Cannot delete the last category."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        category.tasks.all().delete()
        return super().destroy(request, *args, **kwargs)


class TodoTaskListCreate(generics.ListCreateAPIView):
    serializer_class = TodoTaskSerializer

    def get_queryset(self):
        qs = TodoTask.objects.filter(user=get_user()).order_by("-created_at")
        category_id = self.request.query_params.get("category_id")
        if category_id:
            qs = qs.filter(category_id=category_id)
        return qs

    def perform_create(self, serializer):
        serializer.save(user=get_user())


class TodoTaskDetail(generics.RetrieveUpdateDestroyAPIView):
    serializer_class = TodoTaskSerializer

    def get_queryset(self):
        return TodoTask.objects.filter(user=get_user())

class CompleteTodoTaskView(APIView):
    def post(self, request, pk):
        task = get_object_or_404(
            TodoTask,
            pk=pk,
            user=get_user(),
        )

        if task.is_completed:
            return Response(
                {
                    "detail": "Task already completed",
                    "already_completed": True,
                },
                status=status.HTTP_200_OK,
            )

        diff = task.custom_difficulty or task.category.difficulty
        xp = (
            calculate_xp(
                module="todos",
                difficulty=diff.name.lower(),
                user=task.user,
            )
            if diff
            else 0
        )

        task.user.add_xp(
            xp=xp,
            source="todo",
            source_id=task.id,
        )

        task.is_completed = True
        task.completed_at = timezone.now()
        task.save(update_fields=["is_completed", "completed_at", "updated_at"])

        return Response(
            {
                "task_id": task.id,
                "xp_gained": xp,
                "total_xp": task.user.total_xp,
                "current_level": task.user.current_level,
            },
            status=status.HTTP_200_OK,
        )


class RandomTodoTaskView(APIView):
    def get(self, request):
        qs = TodoTask.objects.filter(
            user=get_user(),
            is_completed=False,
        )

        category_id = request.query_params.get("category_id")
        if category_id:
            qs = qs.filter(category_id=category_id)

        if not qs.exists():
            return Response(None, status=status.HTTP_200_OK)

        task = random.choice(list(qs))
        return Response(TodoTaskSerializer(task).data)

class CategoryHasUncompletedTasksView(APIView):
    def get(self, request, category_id):
        exists = TodoTask.objects.filter(
            user=get_user(),
            category_id=category_id,
            is_completed=False,
        ).exists()

        return Response({"has_tasks": exists})

########## KONIEC PLIKU: backend\apps\todos\views.py ##########



########## START PLIK: frontend\constants\theme.ts ##########

export const colors = {
  text: "#dfdef3",
  background: "#1c1c25",
  card: "#393952ff",
  button: "#393952ff",
  buttonActive: "#c4a7e7",
  inputBorder: "#908bab",
  inputBorderActive: "#c4a7e7",
  deleteButton: "#daa7e7",
  light: "#FFFFF1",
  special: "#8162a7"
};

export const fonts = {
  interRegular: "Inter_400Regular",
  interMedium: "Inter_500Medium",
  interSemiBold: "Inter_600SemiBold",
  interBold: "Inter_700Bold",

  poppinsRegular: "Poppins_400Regular",
  poppinsSemiBold: "Poppins_600SemiBold",

  nunitoRegular: "Nunito_400Regular",
  nunitoBold: "Nunito_700Bold",

  manropeRegular: "Manrope_400Regular",
  manropeSemiBold: "Manrope_600SemiBold",
};


export const spacing = {
  xs: 6,
  s: 6,
  m: 16,
  l: 22,
  xl: 32,
};

export const radius = {
  sm: 6,
  md: 10,
  lg: 14,
};

export const components = {
    container: {
    padding: spacing.m,
    marginVertical: spacing.s,
    borderRadius: radius.md,
    backgroundColor: colors.card,
  },
  addButton: {
    backgroundColor: "#908bab",
    borderRadius: 20,
    width: 40,
    height: 40,
    justifyContent: "center",
    alignItems: "center",
  } as const,
  completeButton: {
    backgroundColor: "#908bab",
    borderRadius: 20,
    paddingHorizontal: 10,
    paddingVertical: 5,
    justifyContent: "center",
    alignItems: "center",
  } as const,
};


########## KONIEC PLIKU: frontend\constants\theme.ts ##########



########## START PLIK: frontend\constants\xpPreview.ts ##########

export const BASE_XP = {
  easy: 10,
  medium: 20,
  hard: 50,
};

export const MODULE_MULTIPLIER = {
  habits: 1.0,
  todos: 0.5,
  challenges: 1.0,
  goals: 1.5,
};

export const CHALLENGE_PERIOD_MULTIPLIER = {
  daily: 1.0,
  weekly: 1.5,
};

export const GOAL_PERIOD_MULTIPLIER = {
  weekly: 1.0,
  monthly: 3.0,
  yearly: 8.0,
};


########## KONIEC PLIKU: frontend\constants\xpPreview.ts ##########



########## START PLIK: frontend\components\AppText.tsx ##########

import { Text, TextProps } from "react-native";
import { colors, fonts } from "../constants/theme";

export default function AppText({ style, ...props }: TextProps) {
  return (
    <Text
      {...props}
      style={[
        {
          color: colors.text,
          fontFamily: fonts.poppinsRegular,
          lineHeight: 20,
        },
        style,
      ]}
    />
  );
}


########## KONIEC PLIKU: frontend\components\AppText.tsx ##########



########## START PLIK: frontend\components\FloatingButton.tsx ##########

import React from "react";
import { TouchableOpacity, StyleSheet } from "react-native";
import AppText from "./AppText";
import { colors } from "../constants/theme";

export default function FloatingButton({ onPress, style, children }: any) {
  return (
    <TouchableOpacity onPress={onPress} style={[styles.button, style]}>
      {children ?? <AppText style={{ fontSize: 32, color: "#fff" }}>+</AppText>}
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  button: {
    position: "absolute",
    right: 20,
    bottom: 20,
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: colors.buttonActive,
    justifyContent: "center",
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 3,
    elevation: 5,
  },
});


########## KONIEC PLIKU: frontend\components\FloatingButton.tsx ##########



########## START PLIK: frontend\components\FormErrorModal.tsx ##########

import React from "react";
import { Modal, View, TouchableOpacity } from "react-native";
import AppText from "./AppText";
import { colors, spacing, radius } from "../constants/theme";

type Props = {
  visible: boolean;
  message: string;
  onClose: () => void;
};

export default function FormErrorModal({ visible, message, onClose }: Props) {
  if (!visible) return null;

  return (
    <Modal transparent animationType="fade">
      <View
        style={{
          flex: 1,
          backgroundColor: "rgba(0,0,0,0.5)",
          justifyContent: "center",
          alignItems: "center",
          padding: spacing.l,
        }}
      >
        <View
          style={{
            width: "100%",
            backgroundColor: colors.card,
            borderRadius: radius.lg,
            padding: spacing.l,
          }}
        >
          <AppText style={{ fontSize: 18, fontWeight: "bold", marginBottom: spacing.s }}>
            Missing information
          </AppText>

          <AppText style={{ marginBottom: spacing.l }}>
            {message}
          </AppText>

          <TouchableOpacity
            onPress={onClose}
            style={{
              backgroundColor: colors.buttonActive,
              padding: spacing.m,
              borderRadius: radius.md,
              alignItems: "center",
            }}
          >
            <AppText style={{ color: "#fff", fontWeight: "bold" }}>
              OK
            </AppText>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
}


########## KONIEC PLIKU: frontend\components\FormErrorModal.tsx ##########



########## START PLIK: frontend\components\ItemDetails.tsx ##########

import { View } from "react-native";
import AppText from "./AppText";
import { colors } from "../constants/theme";

type ItemDetailsProps = {
  description?: string;
  motivation?: string;
};

export function ItemDetails({ description, motivation }: ItemDetailsProps) {
  if (!description && !motivation) return null;

  return (
    <View style={{ marginTop: 8 }}>
      {description && (
        <AppText style={{ marginBottom: motivation ? 6 : 0, fontSize: 12, }}>
          {description}
        </AppText>
      )}

      {motivation && (
        <AppText
          style={{
            fontSize: 12,
            opacity: 0.8,
            color: colors.light
          }}
        >
          Motivation: {motivation}
        </AppText>
      )}
    </View>
  );
}


########## KONIEC PLIKU: frontend\components\ItemDetails.tsx ##########



########## START PLIK: frontend\components\ItemHeader.tsx ##########

import { View } from "react-native";
import AppText from "./AppText";

type ItemHeader = {
  title: string;
  difficulty?: string;
};

export function ItemHeader({ title, difficulty }: ItemHeader) {
  return (
    <View style={{ flex: 1 }}>
      <AppText style={{ fontWeight: "bold" }}>{title}</AppText>

      {difficulty && (
        <AppText
          style={{
            fontSize: 12,
            color: "#777",
            marginTop: 4,
          }}
        >
          {difficulty}
        </AppText>
      )}
    </View>
  );
}


########## KONIEC PLIKU: frontend\components\ItemHeader.tsx ##########



########## START PLIK: frontend\components\NavigationHeader.tsx ##########

import { Ionicons } from "@expo/vector-icons";
import { Pressable } from "react-native";
import { router } from "expo-router";
import { colors, fonts } from "../constants/theme";


export const defaultHeaderOptions = {
  headerShown: true,
  headerStyle: {
    backgroundColor: colors.background,
  },
  headerTitleStyle: {
    color: colors.text,
    fontSize: 20,
    fontFamily: fonts.nunitoRegular,
  },
  headerShadowVisible: false,

  headerLeft: () => (
    <Pressable
      onPress={() => router.back()}
      hitSlop={10}
      style={{ paddingRight: 12 }}
    >
      <Ionicons name="arrow-back" size={22} color={colors.text} />
    </Pressable>
  ),
};


########## KONIEC PLIKU: frontend\components\NavigationHeader.tsx ##########



########## START PLIK: frontend\components\RandomResultCard.tsx ##########

import React from "react";
import { Animated, View } from "react-native";
import AppText from "./AppText";
import { colors } from "../constants/theme";

type Props = {
  title: string;
  description?: string;
  animatedStyle?: any;
  highlight?: boolean;
};

export default function RandomResultCard({
  title,
  description,
  animatedStyle,
}: Props) {
  const Wrapper: any = animatedStyle ? Animated.View : View;

  return (
    <Wrapper
      style={[
        {
          padding: 28,
          borderWidth: 2,
          borderRadius: 16,
          borderColor: colors.light,
          backgroundColor: colors.card,
          alignSelf: "center",
          maxWidth: "90%",
          marginVertical: 32,
        },
        animatedStyle,
      ]}
    >
      <AppText
        numberOfLines={3}
        style={{
          fontSize: 20,
          fontWeight: "800",
          textAlign: "center",
          lineHeight: 32,
          marginBottom: description ? 8 : 0,
        }}
      >
        {title}
      </AppText>

      {description && (
        <AppText style={{ textAlign: "center", opacity: 0.9 }}>
          {description}
        </AppText>
      )}
    </Wrapper>
  );
}


########## KONIEC PLIKU: frontend\components\RandomResultCard.tsx ##########



########## START PLIK: frontend\components\XPPopup.tsx ##########

import React, { useEffect, useRef } from "react";
import { Animated, StyleSheet, View } from "react-native";
import AppText from "./AppText";
import { useGamificationStore } from "../app/stores/useGamificationStore";
import { colors } from "../constants/theme";

export default function XPPopup() {
  const { xpPopup, clearXpPopup } = useGamificationStore();
  const translateY = useRef(new Animated.Value(30)).current;
  const opacity = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (!xpPopup) return;

    Animated.parallel([
      Animated.timing(opacity, {
        toValue: 1,
        duration: 250,
        useNativeDriver: true,
      }),
      Animated.timing(translateY, {
        toValue: 0,
        duration: 250,
        useNativeDriver: true,
      }),
    ]).start();

    const timer = setTimeout(() => {
      Animated.parallel([
        Animated.timing(opacity, {
          toValue: 0,
          duration: 250,
          useNativeDriver: true,
        }),
        Animated.timing(translateY, {
          toValue: -20,
          duration: 250,
          useNativeDriver: true,
        }),
      ]).start(() => clearXpPopup());
    }, 1600);

    return () => clearTimeout(timer);
  }, [xpPopup]);

  if (!xpPopup) return null;

  return (
    <Animated.View
      style={[
        styles.container,
        {
          opacity,
          transform: [{ translateY }],
        },
      ]}
    >
      <View style={styles.card}>
        <AppText style={styles.xpText}>+{xpPopup.xp} XP</AppText>
        {xpPopup.levelUp && (
          <AppText style={styles.levelUp}>LEVEL UP</AppText>
        )}
      </View>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: "absolute",
    top: 70,
    left: 0,
    right: 0,
    alignItems: "center",
    zIndex: 999,
  },
  card: {
    backgroundColor: colors.special,
    paddingVertical: 10,
    paddingHorizontal: 18,
    borderRadius: 14,
    alignItems: "center",
  },
  xpText: {
    color: "#fff",
    fontSize: 16,
    fontWeight: "700",
  },
  levelUp: {
    marginTop: 2,
    fontSize: 12,
    color: "#fff",
    opacity: 0.85,
  },
});


########## KONIEC PLIKU: frontend\components\XPPopup.tsx ##########



########## START PLIK: frontend\components\confirmDelete.tsx ##########

import { Alert } from "react-native";

export function confirmDelete({
  title = "Delete?",
  message = "This action cannot be undone.",
  onConfirm,
}: {
  title?: string;
  message?: string;
  onConfirm: () => void;
}) {
  Alert.alert(
    title,
    message,
    [
      { text: "Cancel", style: "cancel" },
      { text: "Delete", style: "destructive", onPress: onConfirm },
    ],
    { cancelable: true }
  );
}


########## KONIEC PLIKU: frontend\components\confirmDelete.tsx ##########



########## START PLIK: frontend\components\dashboard\BiggestStreak.tsx ##########

import React from "react";
import { TouchableOpacity } from "react-native";
import AppText from "../AppText";
import { colors } from "../../constants/theme";
import { BestHabitStreak } from "../../app/stores/useHabitStore";

type Props = {
  streak: BestHabitStreak | null;
  onPress: () => void;
  onEditHabit?: (habitId: number) => void;
};

export function BiggestStreakTile({
  streak,
  onPress,
  onEditHabit,
}: Props) {
  return (
    <TouchableOpacity
      onPress={onPress}
      onLongPress={() =>
        streak?.habit_id && onEditHabit?.(streak.habit_id)
      }
      style={{
        backgroundColor: colors.card,
        padding: 12,
        borderRadius: 12,
        marginBottom: 12
      }}
    >
      <AppText style={{ fontWeight: "700" }}>Biggest streak</AppText>

      {streak?.title ? (
        <AppText>
          {streak.title} • {streak.biggest_streak} dni
        </AppText>
      ) : (
        <AppText style={{ opacity: 0.6 }}>no streak</AppText>
      )}
    </TouchableOpacity>
  );
}


########## KONIEC PLIKU: frontend\components\dashboard\BiggestStreak.tsx ##########



########## START PLIK: frontend\components\dashboard\DailyChallengeTile.tsx ##########

import React from "react";
import { View, TouchableOpacity } from "react-native";
import AppText from "../AppText";
import { colors } from "../../constants/theme";

type Props = {
  activeDaily: any | null;
  onGoToActive: () => void;
  onRandomize: () => void;
  onEdit?: (challengeId: number) => void;
};

export function DailyChallengeTile({
  activeDaily,
  onGoToActive,
  onRandomize,
  onEdit,
}: Props) {
  return (
    <View style={{ marginBottom: 12 }}>
      <AppText style={{ fontWeight: "700", marginBottom: 8 }}>
        Daily challenge
      </AppText>

      {activeDaily ? (
        <TouchableOpacity
          onPress={onGoToActive}
          onLongPress={() =>
            onEdit?.(activeDaily.challenge.id)
          }
          style={{
            backgroundColor: colors.card,
            padding: 12,
            borderRadius: 10,
          }}
        >
          <AppText style={{ fontWeight: "700" }}>
            {activeDaily.challenge?.title}
          </AppText>
          <AppText numberOfLines={2}>
            {activeDaily.challenge?.description}
          </AppText>
        </TouchableOpacity>
      ) : (
        <TouchableOpacity
          onPress={onRandomize}
          style={{
            backgroundColor: colors.buttonActive,
            padding: 12,
            borderRadius: 10,
          }}
        >
          <AppText style={{ color: "#fff", fontWeight: "700" }}>
            Randomize challenge
          </AppText>
        </TouchableOpacity>
      )}
    </View>
  );
}


########## KONIEC PLIKU: frontend\components\dashboard\DailyChallengeTile.tsx ##########



########## START PLIK: frontend\components\dashboard\LevelTile.tsx ##########

import React from "react";
import { View, TouchableOpacity } from "react-native";
import AppText from "../AppText";
import { colors } from "../../constants/theme";

type Props = {
  level: number;
  totalXp: number;
  onPress: () => void;
};

const xpForLevel = (lvl: number) => 50 * lvl * (lvl - 1);

export function LevelTile({ level, totalXp, onPress }: Props) {
  const nextLevelXp = xpForLevel(level + 1);
  const currentLevelXp = xpForLevel(level);
  const progress =
    (totalXp - currentLevelXp) / (nextLevelXp - currentLevelXp);

  const xpRemaining = Math.max(0, nextLevelXp - totalXp);

  return (
    <TouchableOpacity
      onPress={onPress}
      style={{
        backgroundColor: colors.card,
        padding: 16,
        borderRadius: 12,
        marginBottom: 20,
      }}
    >
      <View
        style={{
          flexDirection: "row",
          justifyContent: "space-between",
          marginBottom: 12,
        }}
      >
        <AppText style={{ fontSize: 18, fontWeight: "700" }}>
          Lv {level}
        </AppText>
        <AppText style={{ fontSize: 14, color: "#777" }}>
          {xpRemaining} XP to next level
        </AppText>
      </View>

      <View
        style={{
          height: 12,
          backgroundColor: "#eee",
          borderRadius: 6,
          overflow: "hidden",
        }}
      >
        <View
          style={{
            width: `${Math.min(100, Math.round(progress * 100))}%`,
            height: 12,
            backgroundColor: colors.buttonActive,
          }}
        />
      </View>
    </TouchableOpacity>
  );
}


########## KONIEC PLIKU: frontend\components\dashboard\LevelTile.tsx ##########



########## START PLIK: frontend\components\dashboard\RandomGoalTile.tsx ##########

import React from "react";
import { View, TouchableOpacity } from "react-native";
import AppText from "../AppText";
import { colors } from "../../constants/theme";

type Props = {
  label: string;
  goal: any;
  onRefresh: () => void;
  onEditGoal?: (goalId: number) => void;
};

export function RandomGoalTile({ label, goal, onRefresh, onEditGoal }: Props) {
  if (!goal) return null;

  return (
    <View style={{ marginBottom: 16 }}>
      <AppText style={{ fontWeight: "700", marginBottom: 8 }}>
        {label}
      </AppText>

      <TouchableOpacity
        onPress={onRefresh}
        onLongPress={() => goal?.id && onEditGoal?.(goal.id)}
        delayLongPress={300}
        style={{
          backgroundColor: colors.card,
          padding: 12,
          borderRadius: 12,
        }}
      >
        <AppText style={{ fontWeight: "600" }}>
          {goal.title}
        </AppText>

        {goal.motivation_reason && (
          <AppText
            style={{
              fontSize: 13,
              opacity: 0.7,
              marginTop: 4,
            }}
          >
            {goal.motivation_reason}
          </AppText>
        )}

      </TouchableOpacity>
    </View>
  );
}


########## KONIEC PLIKU: frontend\components\dashboard\RandomGoalTile.tsx ##########



########## START PLIK: frontend\components\dashboard\RandomHabitTile.tsx ##########

import React from "react";
import { View, TouchableOpacity } from "react-native";
import AppText from "../AppText";
import { colors } from "../../constants/theme";

type RandomHabit = {
  id: number;
  title: string;
  reason?: string;
  done: number;
  total: number;
};

type Props = {
  habit: RandomHabit | null;
  onRefresh: () => void;
  onEdit: (id: number) => void;
};

export function RandomHabitTile({ habit, onRefresh, onEdit }: Props) {
  if (!habit) return null;

  return (
    <View style={{ marginBottom: 16 }}>
      <AppText style={{ fontWeight: "700", marginBottom: 8 }}>
        Random habit
      </AppText>

      <TouchableOpacity
        onPress={onRefresh}
        onLongPress={() => onEdit(habit.id)}
        style={{
          backgroundColor: colors.card,
          padding: 12,
          borderRadius: 12,
        }}
      >
        <AppText style={{ fontWeight: "600" }}>
          {habit.title}
        </AppText>

        {habit.reason ? (
          <AppText
            style={{
              fontSize: 13,
              opacity: 0.7,
              marginTop: 4,
            }}
          >
            {habit.reason}
          </AppText>
        ) : null}

        <AppText style={{ marginTop: 6 }}>
          {habit.done} / {habit.total} days
        </AppText>
      </TouchableOpacity>
    </View>
  );
}


########## KONIEC PLIKU: frontend\components\dashboard\RandomHabitTile.tsx ##########



########## START PLIK: frontend\components\dashboard\RandomNoteTile.tsx ##########

import React from "react";
import { View, TouchableOpacity } from "react-native";
import AppText from "../AppText";
import { colors } from "../../constants/theme";

type Props = {
  note: any | null;
  onRefresh: () => void;
  onEdit: (id: number) => void;
  onAdd: () => void;
};

export function RandomNoteTile({
  note,
  onRefresh,
  onEdit,
  onAdd,
}: Props) {
  return (
    <View style={{ marginBottom: 16 }}>
      <AppText style={{ fontWeight: "700", marginBottom: 8 }}>
        Note
      </AppText>

      <View style={{ flexDirection: "row", alignItems: "stretch" }}>
        {note ? (
          <TouchableOpacity
            onPress={onRefresh}
            onLongPress={() => onEdit(note.id)}
            style={{
              flex: 1,
              backgroundColor: colors.card,
              padding: 14,
              borderRadius: 12,
              marginRight: 8,
            }}
          >
            <AppText>{note.content}</AppText>
          </TouchableOpacity>
        ) : (
          <View
            style={{
              flex: 1,
              backgroundColor: colors.card,
              padding: 14,
              borderRadius: 12,
              marginRight: 8,
              justifyContent: "center",
            }}
          >
            <AppText style={{ opacity: 0.6 }}>No notes</AppText>
          </View>
        )}

        <TouchableOpacity
          onPress={onAdd}
          style={{
            width: 44,
            borderRadius: 10,
            backgroundColor: colors.buttonActive,
            alignItems: "center",
            justifyContent: "center",
          }}
        >
          <AppText style={{ color: "#fff", fontSize: 22 }}>+</AppText>
        </TouchableOpacity>
      </View>
    </View>
  );
}


########## KONIEC PLIKU: frontend\components\dashboard\RandomNoteTile.tsx ##########



########## START PLIK: frontend\components\dashboard\RandomTodoTile.tsx ##########

import React from "react";
import { View, TouchableOpacity } from "react-native";
import AppText from "../AppText";
import { colors } from "../../constants/theme";

type Props = {
  todo: any | null;
  onRefresh: () => void;
  onEdit: (id: number) => void;
};

export function RandomTodoTile({ todo, onRefresh, onEdit }: Props) {
  if (!todo) return null;

  return (
    <View style={{ marginBottom: 16 }}>
      <AppText style={{ fontWeight: "700", marginBottom: 8 }}>
        Random todo
      </AppText>

      <TouchableOpacity
        onPress={onRefresh}
        onLongPress={() => onEdit(todo)}
        delayLongPress={300}
        style={{
          backgroundColor: colors.card,
          padding: 12,
          borderRadius: 12,
        }}
      >
        <AppText>{todo.content}</AppText>
      </TouchableOpacity>
    </View>
  );
}


########## KONIEC PLIKU: frontend\components\dashboard\RandomTodoTile.tsx ##########



########## START PLIK: frontend\components\dashboard\WeeklyChallengeTile.tsx ##########

import React from "react";
import { View, TouchableOpacity } from "react-native";
import AppText from "../AppText";
import { colors } from "../../constants/theme";

type Props = {
  activeWeekly: any[];
  onGoToActive: () => void;
  onRandomize: () => void;
  onEdit?: (challengeId: number) => void;
};

export function WeeklyChallengeTile({
  activeWeekly,
  onGoToActive,
  onRandomize,
  onEdit,
}: Props) {
  return (
    <View style={{ marginBottom: 12 }}>
      <AppText style={{ fontWeight: "700", marginBottom: 8 }}>
        Week challenge
      </AppText>

      {activeWeekly && activeWeekly.length > 0 ? (
        activeWeekly.map((uc) => {
          const days = uc.progress_days ?? 0;
          const progress = Math.min(100, (days / 7) * 100);

          return (
            <TouchableOpacity
              key={uc.id}
              onPress={onGoToActive}
              onLongPress={() =>
                onEdit?.(uc.challenge.id)
              }
              style={{
                backgroundColor: colors.card,
                padding: 12,
                borderRadius: 10,
                marginBottom: 8,
              }}
            >
              <AppText style={{ fontWeight: "700" }}>
                {uc.challenge?.title}
              </AppText>

              <View
                style={{
                  height: 8,
                  backgroundColor: colors.light,
                  borderRadius: 6,
                  overflow: "hidden",
                  marginTop: 8,
                }}
              >
                <View
                  style={{
                    width: `${progress}%`,
                    height: 8,
                    backgroundColor: colors.buttonActive,
                  }}
                />
              </View>

              <AppText style={{ marginTop: 6 }}>
                {days}/7 dni
              </AppText>
            </TouchableOpacity>
          );
        })
      ) : (
        <TouchableOpacity
          onPress={onRandomize}
          style={{
            backgroundColor: colors.buttonActive,
            padding: 12,
            borderRadius: 10,
          }}
        >
          <AppText style={{ color: "#fff", fontWeight: "700" }}>
            Randomize challenge
          </AppText>
        </TouchableOpacity>
      )}
    </View>
  );
}


########## KONIEC PLIKU: frontend\components\dashboard\WeeklyChallengeTile.tsx ##########



########## START PLIK: frontend\features\challenges\ChallengeFormScreen.tsx ##########

import React, { useEffect, useState } from "react";
import { View, TextInput, TouchableOpacity, ScrollView, ActivityIndicator } from "react-native";
import { useRouter } from "expo-router";
import { useChallengeStore, ChallengeType, DifficultyType } from "../../app/stores/useChallengeStore";
import { colors, spacing, radius } from "../../constants/theme";
import AppText from "../../components/AppText";
import FormErrorModal from "../../components/FormErrorModal";
import { confirmDelete } from "../../components/confirmDelete";

export type ChallengeFormScreenProps = {
  editingId?: number;
};

export default function ChallengeFormScreen({ editingId }: ChallengeFormScreenProps) {
  const router = useRouter();

  const {
    tags,
    difficulties,
    loadTags,
    loadDifficulties,
    loadChallenges,

    getChallengeById,
    loadTypes,
    createChallenge,
    updateChallenge,
    deleteChallenge,
  } = useChallengeStore();

  const [title, setTitle] = useState("");
  const [description, setDescription] = useState("");
  const [type, setType] = useState<ChallengeType | null>(null);
  const [difficulty, setDifficulty] = useState<DifficultyType | null>(null);
  const [selectedTags, setSelectedTags] = useState<number[]>([]);
  const [availableTypes, setAvailableTypes] = useState<ChallengeType[]>([]);

  const [loading, setLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  useEffect(() => {
    loadTags();
    loadDifficulties();

    const loadMeta = async () => {
      const types = await loadTypes();
      setAvailableTypes(types);
    };

    loadMeta();
  }, []);

  useEffect(() => {
    if (!editingId) return;

    const load = async () => {
      setLoading(true);
      const c = await getChallengeById(editingId);

      if (!c) {
        setErrorMessage("Failed to load challenge");
      } else {
        setTitle(c.title);
        setDescription(c.description);
        setType(c.type);
        setDifficulty(c.difficulty);
        setSelectedTags(c.tags.map(t => t.id));
      }

      setLoading(false);
    };

    load();
  }, [editingId]);

  const toggleTag = (id: number) => {
    setSelectedTags(prev =>
      prev.includes(id) ? prev.filter(x => x !== id) : [...prev, id]
    );
  };

  const save = async () => {
    if (!title.trim()) {
      setErrorMessage("Please enter challenge name");
      return;
    }
    if (!type) {
      setErrorMessage("Please select challenge type");
      return;
    }
    if (!difficulty) {
      setErrorMessage("Please select difficulty");
      return;
    }
    if (selectedTags.length === 0) {
      setErrorMessage("Please select at least one tag");
      return;
    }

    setLoading(true);

    const payload = {
      title,
      description,
      type_id: type.id,
      difficulty_id: difficulty.id,
      tags_ids: selectedTags,
    };

    try {
      if (editingId) {
        await updateChallenge(editingId, payload);
      } else {
        await createChallenge(payload);
      }

      await loadChallenges();
      router.back();
    } catch (err: any) {
      setErrorMessage(
        err?.response?.data?.detail || "Failed to save challenge"
      );
    } finally {
      setLoading(false);
    }
  };

  const deleteHandler = async () => {
    if (!editingId) return;

    setLoading(true);
    try {
      await deleteChallenge(editingId);
      await loadChallenges();
      router.back();
    } catch (err: any) {
      setErrorMessage(
        err?.response?.data?.detail || "Failed to delete challenge"
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <ScrollView
        style={{ flex: 1, padding: spacing.m, backgroundColor: colors.background }}
        contentContainerStyle={{ paddingBottom: 30 }}
      >
        <AppText style={{ marginBottom: 6 }}>Name:</AppText>
        <TextInput
          value={title}
          onChangeText={setTitle}
          placeholderTextColor="#7a7891"
          style={{
            borderWidth: 1,
            borderColor: colors.inputBorder,
            color: colors.text,
            padding: spacing.s,
            borderRadius: radius.md,
            marginBottom: spacing.m,
          }}
        />

        <AppText style={{ marginBottom: 6 }}>Description:</AppText>
        <TextInput
          value={description}
          onChangeText={setDescription}
          multiline
          placeholderTextColor="#7a7891"
          style={{
            borderWidth: 1,
            borderColor: colors.inputBorder,
            color: colors.text,
            padding: spacing.s,
            borderRadius: radius.md,
            marginBottom: spacing.m,
            minHeight: 90,
          }}
        />

        <AppText style={{ marginBottom: 6 }}>Type:</AppText>
        <View style={{ flexDirection: "row", flexWrap: "wrap", marginBottom: spacing.m }}>
          {availableTypes.map(t => (
            <TouchableOpacity
              key={t.id}
              disabled={loading}
              onPress={() => setType(t)}
              style={{
                padding: spacing.s,
                borderRadius: radius.md,
                marginRight: spacing.s,
                marginBottom: spacing.s,
                backgroundColor:
                  type?.id === t.id ? colors.buttonActive : colors.button,
              }}
            >
              <AppText>{t.name}</AppText>
            </TouchableOpacity>
          ))}
        </View>

        <AppText style={{ marginBottom: 6 }}>Difficulty:</AppText>
        <View style={{ flexDirection: "row", flexWrap: "wrap", marginBottom: spacing.m }}>
          {difficulties.map(d => (
            <TouchableOpacity
              key={d.id}
              disabled={loading}
              onPress={() => setDifficulty(d)}
              style={{
                padding: spacing.s,
                borderRadius: radius.md,
                marginRight: spacing.s,
                marginBottom: spacing.s,
                backgroundColor:
                  difficulty?.id === d.id ? colors.buttonActive : colors.button,
              }}
            >
              <AppText>{d.name}</AppText>
            </TouchableOpacity>
          ))}
        </View>

        <AppText style={{ marginBottom: 6 }}>Tags:</AppText>
        <View style={{ flexDirection: "row", flexWrap: "wrap", marginBottom: spacing.l }}>
          {tags.map(tag => (
            <TouchableOpacity
              key={tag.id}
              disabled={loading}
              onPress={() => toggleTag(tag.id)}
              style={{
                paddingVertical: 6,
                paddingHorizontal: 10,
                borderRadius: radius.md,
                marginRight: spacing.s,
                marginBottom: spacing.s,
                backgroundColor: selectedTags.includes(tag.id)
                  ? colors.buttonActive
                  : colors.button,
              }}
            >
              <AppText>{tag.name}</AppText>
            </TouchableOpacity>
          ))}
        </View>

        <TouchableOpacity
          onPress={save}
          disabled={loading}
          style={{
            backgroundColor: colors.buttonActive,
            padding: spacing.m,
            borderRadius: radius.md,
            alignItems: "center",
            marginBottom: editingId ? spacing.m : 0,
          }}
        >
          {loading ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <AppText style={{ color: "#fff", fontWeight: "bold" }}>
              {editingId ? "Save" : "Add challenge"}
            </AppText>
          )}
        </TouchableOpacity>

        {editingId && (
          <TouchableOpacity
            disabled={loading}
            onPress={() =>
              confirmDelete({
                title: "Delete challenge?",
                message: "This challenge will be permanently removed.",
                onConfirm: deleteHandler,
              })
            }
            style={{
              backgroundColor: colors.deleteButton,
              padding: spacing.m,
              borderRadius: radius.md,
              alignItems: "center",
              marginBottom: spacing.l,
            }}
          >
            <AppText style={{ color: "#fff", fontWeight: "bold" }}>
              Delete challenge
            </AppText>
          </TouchableOpacity>
        )}
      </ScrollView>

      <FormErrorModal
        visible={!!errorMessage}
        message={errorMessage || ""}
        onClose={() => setErrorMessage(null)}
      />
    </>
  );
}


########## KONIEC PLIKU: frontend\features\challenges\ChallengeFormScreen.tsx ##########



########## START PLIK: frontend\features\challenges\ChallengeItem.tsx ##########

import React, { useState } from "react";
import { View, TouchableOpacity, Alert } from "react-native";
import { router } from "expo-router";
import { useChallengeStore } from "../../app/stores/useChallengeStore";
import AppText from "../../components/AppText";
import { colors, components } from "../../constants/theme";
import { useModuleSettingsStore } from "../../app/stores/useModuleSettingsStore";
import { useGamificationStore } from "../../app/stores/useGamificationStore";
import { ItemHeader } from "../../components/ItemHeader";
import { ItemDetails } from "../../components/ItemDetails";

type Props = {
  item: any;
  isUserChallenge: boolean;
};

export default function ChallengeItem({ item, isUserChallenge }: Props) {
  const [expanded, setExpanded] = useState(false);

  const { modules } = useModuleSettingsStore();
  const gamificationOn = modules?.gamification;

  const {
    assignChallenge,
    completeUserChallenge,
    fetchActive,
  } = useChallengeStore();

  const onAssign = async () => {
    const res = await assignChallenge(item.id);
    if (!res) {
      Alert.alert("Error", "Cannot assign challenge.");
    }
    await fetchActive();
  };

  const onComplete = async () => {
    const res = await completeUserChallenge(item.id);

    if (!res) {
      Alert.alert("Error", "Cannot complete challenge.");
      return;
    }

    if (gamificationOn && res.xp_gained > 0) {
      useGamificationStore.getState().applyXpResult(res);
    }

    await fetchActive();
  };

  const isWeekly =
    isUserChallenge &&
    item.challenge_type === "weekly";

  const days = isWeekly ? (item.progress_days || 1) : 0;


return (
  <TouchableOpacity
    onPress={() => setExpanded(prev => !prev)}
    onLongPress={() => router.push(`/editChallenge/${item.challenge.id}`)}
    delayLongPress={300}
  >
    <View style={components.container}>
      <View style={{ flexDirection: "row", justifyContent: "space-between" }}>
        <ItemHeader
          title={isUserChallenge ? item.challenge.title : item.title}
          difficulty={
            isUserChallenge
              ? item.challenge.difficulty?.name
              : item.difficulty?.name
          }
        />

        <View style={{ flexDirection: "row", gap: 8 }}>
          {!isUserChallenge && (
            <TouchableOpacity onPress={onAssign} style={components.addButton}>
              <AppText style={{ color: "#fff", fontSize: 18 }}>+</AppText>
            </TouchableOpacity>
          )}

        {isUserChallenge && (
          <TouchableOpacity onPress={onComplete} style={components.completeButton}>
            <AppText style={{ color: "#fff", fontSize: 14 }}>
              Complete
            </AppText>
          </TouchableOpacity>
        )}

        </View>
      </View>

      {isWeekly && (
        <>
          <View
            style={{
              height: 8,
              backgroundColor: colors.light,
              borderRadius: 4,
              marginVertical: 8,
            }}
          >
            <View
              style={{
                width: `${(days / 7) * 100}%`,
                height: 8,
                backgroundColor: colors.buttonActive,
              }}
            />
          </View>
          <AppText style={{ fontSize: 12, marginTop: 2 }}>
            {days}/7 dni
          </AppText>
        </>
      )}

      {expanded && (
        <ItemDetails
          description={
            isUserChallenge
              ? item.challenge.description
              : item.description
          }
        />
      )}
    </View>
  </TouchableOpacity>
);
}


########## KONIEC PLIKU: frontend\features\challenges\ChallengeItem.tsx ##########



########## START PLIK: frontend\features\challenges\TagsFormScreen.tsx ##########

import React, { useEffect, useState } from "react";
import {
  TextInput,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
} from "react-native";
import { useRouter } from "expo-router";
import AppText from "../../components/AppText";
import { colors, radius, spacing } from "../../constants/theme";
import FormErrorModal from "../../components/FormErrorModal";
import { confirmDelete } from "../../components/confirmDelete";
import { useChallengeStore } from "../../app/stores/useChallengeStore";

export type TagsFormScreenProps = {
  editingId?: number;
};

export default function TagsFormScreen({ editingId }: TagsFormScreenProps) {
  const router = useRouter();

  const {
    loadTags,
    getTagById,
    createTag,
    updateTag,
    deleteTag,
  } = useChallengeStore();

  const [name, setName] = useState("");
  const [loading, setLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  useEffect(() => {
    if (!editingId) return;

    const load = async () => {
      setLoading(true);
      const tag = await getTagById(editingId);

      if (!tag) {
        setErrorMessage("Cannot load tag");
      } else {
        setName(tag.name);
      }

      setLoading(false);
    };

    load();
  }, [editingId]);

  const save = async () => {
    if (!name.trim()) {
      setErrorMessage("Please enter tag name");
      return;
    }

    setLoading(true);
    try {
      if (editingId) {
        await updateTag(editingId, { name: name.trim() });
      } else {
        await createTag({ name: name.trim() });
      }

      await loadTags();
      router.back();
    } catch (err: any) {
      setErrorMessage(
        err?.response?.data?.detail || "Cannot save tag"
      );
    }
    finally {
      setLoading(false);
    }
  };

  const deleteHandler = async () => {
    if (!editingId) return;

    setLoading(true);
    try {
      await deleteTag(editingId);
      await loadTags();
      router.back();
    } catch (err: any) {
      setErrorMessage(
        err?.response?.data?.detail || "Cannot delete tag"
      );
    }
    finally {
      setLoading(false);
    }
  };

  return (
    <>
      <ScrollView
        style={{ flex: 1, padding: spacing.m, backgroundColor: colors.background }}
        contentContainerStyle={{ paddingBottom: 30 }}
      >
        <AppText style={{ color: colors.text, marginBottom: 6 }}>
          Tag name:
        </AppText>

        <TextInput
          value={name}
          onChangeText={setName}
          editable={!loading}
          placeholderTextColor="#7a7891"
          style={{
            borderWidth: 1,
            borderColor: colors.inputBorder,
            borderRadius: radius.md,
            padding: 10,
            marginBottom: spacing.m,
            color: colors.text,
          }}
        />

        <TouchableOpacity
          onPress={save}
          disabled={loading}
          style={{
            backgroundColor: colors.buttonActive,
            padding: spacing.m,
            borderRadius: radius.md,
            alignItems: "center",
            marginBottom: editingId ? spacing.s : 0,
          }}
        >
          {loading ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <AppText style={{ color: "#fff", fontWeight: "bold" }}>
              {editingId ? "Save" : "Add tag"}
            </AppText>
          )}
        </TouchableOpacity>

        {editingId && (
          <TouchableOpacity
            disabled={loading}
            onPress={() =>
              confirmDelete({
                title: "Delete tag?",
                message: "This tag will be permanently removed.",
                onConfirm: deleteHandler,
              })
            }
            style={{
              backgroundColor: colors.deleteButton,
              padding: spacing.m,
              borderRadius: radius.md,
              alignItems: "center",
            }}
          >
            <AppText style={{ color: "#fff", fontWeight: "bold" }}>
              Delete tag
            </AppText>
          </TouchableOpacity>
        )}
      </ScrollView>

      <FormErrorModal
        visible={!!errorMessage}
        message={errorMessage || ""}
        onClose={() => setErrorMessage(null)}
      />
    </>
  );
}


########## KONIEC PLIKU: frontend\features\challenges\TagsFormScreen.tsx ##########



########## START PLIK: frontend\features\goals\GoalFormScreen.tsx ##########

import React, { useEffect, useState } from "react";
import {
  View,
  TextInput,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
} from "react-native";
import { useRouter } from "expo-router";
import { useGoalStore } from "../../app/stores/useGoalStore";
import AppText from "../../components/AppText";
import { colors, spacing, radius } from "../../constants/theme";
import FormErrorModal from "../../components/FormErrorModal";
import { confirmDelete } from "../../components/confirmDelete";

export type GoalFormScreenProps = {
  editingId?: number;
};

export default function GoalFormScreen({ editingId }: GoalFormScreenProps) {
  const router = useRouter();

  const {
    periods,
    loadPeriods,
    getGoalById,
    loadDifficulties,
    createGoal,
    saveGoal,
    deleteGoal,
  } = useGoalStore();

  const [title, setTitle] = useState("");
  const [description, setDescription] = useState("");
  const [why, setWhy] = useState("");
  const [period, setPeriod] = useState<number | null>(null);
  const [difficultyId, setDifficultyId] = useState<number | null>(null);
  const [availableDifficulties, setAvailableDifficulties] = useState<any[]>([]);
  const [selectedPeriodObj, setSelectedPeriodObj] = useState<any | null>(null);

  const [loading, setLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  useEffect(() => {
    loadPeriods();

    const loadMeta = async () => {
      const diffs = await loadDifficulties();
      setAvailableDifficulties(diffs);
    };

    loadMeta();
  }, []);

  useEffect(() => {
    if (!editingId) return;

    const load = async () => {
      setLoading(true);
      const g = await getGoalById(editingId);

      if (!g) {
        setErrorMessage("Failed to load goal");
      } else {
        setTitle(g.title);
        setDescription(g.description);
        setWhy(g.motivation_reason || "");
        setPeriod(g.period?.id || null);
        setSelectedPeriodObj(g.period || null);
        setDifficultyId(g.difficulty?.id || null);
      }

      setLoading(false);
    };

    load();
  }, [editingId]);

  useEffect(() => {
    if (!period && editingId && periods.length > 0) {
      const g = periods.find((x) => x.id === selectedPeriodObj?.id);
      if (g) setPeriod(g.id);
    }
  }, [periods]);

  const save = async () => {
    if (!title.trim()) {
      setErrorMessage("Please enter goal name");
      return;
    }
    if (!difficultyId) {
      setErrorMessage("Please select difficulty");
      return;
    }
    if (!why.trim()) {
      setErrorMessage("Please enter Why it's important");
      return;
    }
    if (!period) {
      setErrorMessage("Please select a period");
      return;
    }

    setLoading(true);

    const payload = {
      title,
      description,
      motivation_reason: why,
      period_id: period,
      difficulty_id: difficultyId,
    };

    try {
      if (editingId) {
        await saveGoal(editingId, payload);
      } else {
        await createGoal(payload);
      }
      router.back();
    } catch (err: any) {
      setErrorMessage(
        err?.response?.data?.detail || "Failed to save goal"
      );
    }
    finally {
      setLoading(false);
    }
  };

  const deleteGoalHandler = async () => {
    if (!editingId) return;

    setLoading(true);
    try {
      await deleteGoal(editingId);
      router.back();
    } catch (err: any) {
      setErrorMessage(
        err?.response?.data?.detail || "Failed to delete goal"
      );
    }
    finally {
      setLoading(false);
    }
  };

  return (
    <>
      <ScrollView
        style={{ flex: 1, padding: spacing.m, backgroundColor: colors.background }}
        contentContainerStyle={{ paddingBottom: 30 }}
      >
        <AppText style={{ marginBottom: 6 }}>Name:</AppText>
        <TextInput
          value={title}
          onChangeText={setTitle}
          placeholderTextColor="#7a7891"
          style={{
            borderWidth: 1,
            borderColor: colors.inputBorder,
            color: colors.text,
            padding: spacing.s,
            borderRadius: radius.md,
            marginBottom: spacing.m,
          }}
        />

        <AppText style={{ marginBottom: 6 }}>Description:</AppText>
        <TextInput
          value={description}
          onChangeText={setDescription}
          multiline
          placeholderTextColor="#7a7891"
          style={{
            borderWidth: 1,
            borderColor: colors.inputBorder,
            color: colors.text,
            padding: spacing.s,
            borderRadius: radius.md,
            marginBottom: spacing.m,
            minHeight: 90,
          }}
        />

        <AppText style={{ marginBottom: 6 }}>Why it's important:</AppText>
        <TextInput
          value={why}
          onChangeText={setWhy}
          multiline
          placeholderTextColor="#7a7891"
          style={{
            borderWidth: 1,
            borderColor: colors.inputBorder,
            color: colors.text,
            padding: spacing.s,
            borderRadius: radius.md,
            marginBottom: spacing.m,
            minHeight: 80,
          }}
        />

        <AppText style={{ marginBottom: 6 }}>Period:</AppText>
        <View style={{ flexDirection: "row", marginBottom: spacing.m }}>
          {periods.map((p: any) => (
            <TouchableOpacity
              key={p.id}
              disabled={loading}
              onPress={() => setPeriod(p.id)}
              style={{
                padding: spacing.s,
                borderRadius: radius.md,
                marginRight: spacing.s,
                backgroundColor:
                  period === p.id ? colors.buttonActive : colors.button,
              }}
            >
              <AppText>{p.name}</AppText>
            </TouchableOpacity>
          ))}
        </View>

        <AppText style={{ marginBottom: 6 }}>Difficulty:</AppText>
        <View style={{ flexDirection: "row", flexWrap: "wrap", marginBottom: spacing.m }}>
          {availableDifficulties.map((d) => (
            <TouchableOpacity
              key={d.id}
              disabled={loading}
              onPress={() => setDifficultyId(d.id)}
              style={{
                padding: spacing.s,
                borderRadius: radius.md,
                marginRight: spacing.s,
                marginBottom: spacing.s,
                backgroundColor:
                  difficultyId === d.id ? colors.buttonActive : colors.button,
              }}
            >
              <AppText>{d.name}</AppText>
            </TouchableOpacity>
          ))}
        </View>

        <TouchableOpacity
          onPress={save}
          disabled={loading}
          style={{
            backgroundColor: colors.buttonActive,
            padding: spacing.m,
            borderRadius: radius.md,
            alignItems: "center",
            marginBottom: editingId ? spacing.m : 0,
          }}
        >
          {loading ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <AppText style={{ color: "#fff", fontWeight: "bold" }}>
              {editingId ? "Save" : "Add goal"}
            </AppText>
          )}
        </TouchableOpacity>

        {editingId && (
          <TouchableOpacity
            disabled={loading}
            onPress={() =>
              confirmDelete({
                title: "Delete goal?",
                message: "This goal will be permanently removed.",
                onConfirm: deleteGoalHandler,
              })
            }
            style={{
              backgroundColor: colors.deleteButton,
              padding: spacing.m,
              borderRadius: radius.md,
              alignItems: "center",
              marginBottom: spacing.l,
            }}
          >
            <AppText style={{ color: "#fff", fontWeight: "bold" }}>
              Delete goal
            </AppText>
          </TouchableOpacity>
        )}
      </ScrollView>

      <FormErrorModal
        visible={!!errorMessage}
        message={errorMessage || ""}
        onClose={() => setErrorMessage(null)}
      />
    </>
  );
}


########## KONIEC PLIKU: frontend\features\goals\GoalFormScreen.tsx ##########



########## START PLIK: frontend\features\goals\GoalItem.tsx ##########

import React from "react";
import { View, TouchableOpacity } from "react-native";
import AppText from "../../components/AppText";
import { components } from "../../constants/theme";
import { ItemDetails } from "../../components/ItemDetails";

type GoalItemProps = {
  item: any;
  isCompleted: boolean;
  isExpanded: boolean;
  onToggleExpand: () => void;
  onComplete: () => void;
  onEdit: () => void;
};

export default function GoalItem({
  item,
  isCompleted,
  isExpanded,
  onToggleExpand,
  onComplete,
  onEdit,
}: GoalItemProps) {
  return (
    <TouchableOpacity
      onPress={onToggleExpand}
      onLongPress={onEdit}
    >
      <View
        style={{
          ...components.container,
          opacity: isCompleted ? 0.5 : 1,
        }}
      >
        <View
          style={{
            flexDirection: "row",
            justifyContent: "space-between",
          }}
        >
        <View style={{ flex: 1 }}>
        <AppText
            style={{
            fontWeight: "bold",
            textDecorationLine: isCompleted ? "line-through" : "none",
            }}
        >
            {item.title}
        </AppText>

        {item.difficulty?.name && (
            <AppText style={{ fontSize: 12, color: "#777" }}>
            {item.difficulty.name}
            </AppText>
        )}
        </View>
          {!isCompleted && (
            <TouchableOpacity
              onPress={onComplete}
              style={components.completeButton}
            >
              <AppText style={{ color: "#fff" }}>complete</AppText>
            </TouchableOpacity>
          )}
        </View>
        {isExpanded && (
          <ItemDetails
            description={item.description}
            motivation={item.motivation_reason}
          />
        )}
      </View>
    </TouchableOpacity>
  );
}


########## KONIEC PLIKU: frontend\features\goals\GoalItem.tsx ##########



########## START PLIK: frontend\features\habits\HabitFormScreen.tsx ##########

import React, { useEffect, useState } from "react";
import { View, TextInput, TouchableOpacity, ScrollView, ActivityIndicator } from "react-native";
import { useRouter } from "expo-router";
import AppText from "../../components/AppText";
import { colors, spacing, radius } from "../../constants/theme";
import { useHabitStore } from "../../app/stores/useHabitStore";
import FormErrorModal from "../../components/FormErrorModal";
import { confirmDelete } from "../../components/confirmDelete";

type HabitFormScreenProps = {
  editingId?: number;
};

export default function HabitFormScreen({ editingId }: HabitFormScreenProps) {
  const router = useRouter();
  const { createHabit, updateHabit, deleteHabit, loadDifficulties, difficulties, getHabitById } = useHabitStore();
  const [title, setTitle] = useState("");
  const [description, setDescription] = useState("");
  const [why, setWhy] = useState("");
  const [difficultyId, setDifficultyId] = useState<number | null>(null);
  const [loading, setLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  const colorPalette = [
    "#908bab",
    "#E5FE86",
    "#825BA5",
    "#83CDEE",
    "#E4BEE6",
    "#EA97DC",
    "#A0B4EF",
  ];

  const [color, setColor] = useState<string>(colorPalette[0]);


  useEffect(() => {
    loadDifficulties();

    if (!editingId) return;

    const load = async () => {
      setLoading(true);
      const h = await getHabitById(editingId);
      if (!h) {
        setErrorMessage("Failed to load habit");
      } else {
        setTitle(h.title);
        setDescription(h.description || "");
        setWhy(h.motivation_reason || "");
        setColor(h.color || colorPalette[0]);
        setDifficultyId(h.difficulty?.id || null);
      }
      setLoading(false);
    };

    load();
  }, [editingId]);

  const save = async () => {
    if (!title.trim()) {
      setErrorMessage("Please enter habit name");
      return;
    }
    if (!difficultyId) {
      setErrorMessage("Please select difficulty");
      return;
    }
    if (!why.trim()) {
      setErrorMessage("Please enter Why it's important");
      return;
    }

    setLoading(true);
    const payload = {
      title,
      description,
      motivation_reason: why,
      color,
      difficulty_id: difficultyId,
    };
    try {
      if (editingId) {
        await updateHabit(editingId, payload);
      } else {
        await createHabit(payload);
      }
      router.back();
    } catch (err: any) {
      setErrorMessage(
        err?.response?.data?.detail || "Failed to save habit"
      );
    }
    finally {
      setLoading(false);
    }
  };

  const onDelete = async () => {
    if (!editingId) return;
    setLoading(true);
    try {
      await deleteHabit(editingId);
      router.back();
    } catch (err: any) {
      setErrorMessage(
        err?.response?.data?.detail || "Failed to delete habit"
       );
    }
    finally {
      setLoading(false);
    }
    
  };

  return (
    <>
    <ScrollView style={{ flex: 1, padding: spacing.m, backgroundColor: colors.background }} contentContainerStyle={{
    paddingBottom: 30
  }}>
      <AppText style={{ marginBottom: 6 }}>Name:</AppText>
        <TextInput 
          value={title} 
          onChangeText={setTitle} 
          style={{ 
            borderWidth: 1, 
            borderColor: 
            colors.inputBorder, 
            color: colors.text, 
            padding: spacing.s, 
            borderRadius: radius.md, 
            marginBottom: spacing.m 
          }} 
          placeholderTextColor="#7a7891" 
        />

      <AppText style={{ marginBottom: 6 }}>Description:</AppText>
        <TextInput 
          value={description} 
          onChangeText={setDescription} 
          multiline 
          style={{ 
            borderWidth: 1, 
            borderColor: colors.inputBorder, 
            color: colors.text, 
            padding: spacing.s, 
            borderRadius: radius.md, 
            marginBottom: spacing.m, 
            minHeight: 90 
            }} 
          placeholderTextColor="#7a7891" 
        />

      <AppText style={{ marginBottom: 6 }}>Why it's important:</AppText>
        <TextInput 
          value={why} 
          onChangeText={setWhy} 
          multiline style={{ 
            borderWidth: 1, 
            borderColor: colors.inputBorder, 
            color: colors.text, 
            padding: spacing.s, 
            borderRadius: radius.md, 
            marginBottom: spacing.m, 
            minHeight: 80 
          }} 
          placeholderTextColor="#7a7891" 
        />

      <AppText style={{ marginBottom: 6 }}>Color:</AppText>
      <View style={{ flexDirection: "row", marginBottom: spacing.m }}>
        {colorPalette.map(c => (
          <TouchableOpacity key={c} onPress={() => setColor(c)} style={{ width: 36, height: 36, borderRadius: 8, backgroundColor: c, marginRight: 8, borderWidth: color === c ? 2 : 0, borderColor: "#fff" }} />
        ))}
      </View>

      <AppText style={{ marginBottom: 6 }}>Difficulty:</AppText>
      <View style={{ flexDirection: "row", flexWrap: "wrap", marginBottom: spacing.m }}>
        {difficulties.map(d => (
          <TouchableOpacity key={d.id} onPress={() => setDifficultyId(d.id)} style={{ padding: spacing.s, borderRadius: radius.md, marginRight: spacing.s, marginBottom: spacing.s, backgroundColor: difficultyId === d.id ? colors.buttonActive : colors.button }}>
            <AppText>
              {d.name}
            </AppText>

          </TouchableOpacity>
        ))}
      </View>

      <TouchableOpacity onPress={save} disabled={loading} style={{ backgroundColor: colors.buttonActive, padding: spacing.m, borderRadius: radius.md, alignItems: "center", marginBottom: editingId ? spacing.m : 0 }}>
        {loading ? <ActivityIndicator color="#fff" /> : <AppText style={{ color: "#fff", fontWeight: "bold" }}>{editingId ? "Save" : "Add habit"}</AppText>}
      </TouchableOpacity>

      {editingId && (
        <TouchableOpacity
          disabled={loading}
          onPress={() =>
            confirmDelete({
              title: "Delete habit?",
              message: "This habit will be permanently removed.",
              onConfirm: onDelete,
            })
          }
          style={{
            backgroundColor: colors.deleteButton,
            padding: spacing.m,
            borderRadius: radius.md,
            alignItems: "center",
          }}
        >
          <AppText style={{ color: "#fff", fontWeight: "bold" }}>
            Delete habit
          </AppText>
        </TouchableOpacity>
      )}
    </ScrollView>
    <FormErrorModal
      visible={!!errorMessage}
      message={errorMessage || ""}
      onClose={() => setErrorMessage(null)}
    />
  </>
);
}


########## KONIEC PLIKU: frontend\features\habits\HabitFormScreen.tsx ##########



########## START PLIK: frontend\features\habits\HabitItem.tsx ##########

import React, { useState } from "react";
import { View, Pressable } from "react-native";
import AppText from "../../components/AppText";
import { colors, components, spacing } from "../../constants/theme";
import { useRouter } from "expo-router";
import { ItemHeader } from "../../components/ItemHeader";
import { ItemDetails } from "../../components/ItemDetails";

type HabitProps = {
  item: any;
  onToggleToday: (habitId: number) => Promise<void>;
  onToggleDay: (habitId: number, date: string, newStatus: number) => Promise<void>;
};

export default function HabitItem({ item, onToggleToday, onToggleDay }: HabitProps) {
  const router = useRouter();
  const [expanded, setExpanded] = useState(false);

  const days = item.days || [];

  return (
    <Pressable
      onPress={() => setExpanded(prev => !prev)}
      onLongPress={() => router.push(`/editHabit/${item.id}`)}
      delayLongPress={300}
      style={({ pressed }) => [
        components.container,
        { opacity: pressed ? 0.9 : 1, marginBottom: spacing.s }
      ]}
    >
      <View style={{ flexDirection: "row", justifyContent: "space-between", alignItems: "center" }}>
        <ItemHeader
            title={item.title}
            difficulty={item.difficulty?.name}
          />

        <Pressable
          onPress={() => onToggleToday(item.id)}
          style={{
            width: 38,
            height: 38,
            borderRadius: 12,
            marginRight: 10,
            backgroundColor: item.color || colors.buttonActive,
            justifyContent: "center",
            alignItems: "center",
          }}
        >
          <AppText style={{ color: "#fff", fontSize: 16 }}>+</AppText>
        </Pressable>

      </View>

      {expanded && (
        <ItemDetails
          description={item.description}
          motivation={item.motivation_reason}
        />
      )}


      <View style={{ flexDirection: "row", flexWrap: "wrap", marginTop: spacing.s }}>
        {days.map((d: any) => {
          const status = d.status;
          const todayStr = new Date().toISOString().slice(0, 10);
          const isFuture = d.date > todayStr;
          const squareStyle: any = {
            width: 26,
            height: 26,
            marginRight: 6,
            marginBottom: 6,
            borderRadius: 6,
            justifyContent: "center",
            alignItems: "center",
          };

          if (isFuture) {
            squareStyle.backgroundColor = "#2b2b35";
          } else if (status === 2) {
            squareStyle.backgroundColor = item.color || colors.buttonActive;
          } else if (status === 1) {
            squareStyle.backgroundColor = "#5a5a66";
          } else {
            squareStyle.backgroundColor = "#22222b";
            squareStyle.borderWidth = 1;
            squareStyle.borderColor = item.color || colors.inputBorder;
          }

          return (
            <Pressable
              key={d.date}
              onPress={async () => {
                const todayStr = new Date().toISOString().slice(0, 10);
                if (d.date > todayStr) {
                  return;
                }
                const newStatus = d.status === 2 ? 1 : 2;
                await onToggleDay(item.id, d.date, newStatus);
              }}
              onLongPress={() => router.push(`/editHabit/${item.id}`)}
              delayLongPress={300}
            >
              <View style={squareStyle}>
                <AppText style={{ fontSize: 10, color: "#fff" }}>
                  {new Date(d.date).getDate()}
                </AppText>
              </View>
            </Pressable>
          );
        })}
      </View>
    </Pressable>
  );
}


########## KONIEC PLIKU: frontend\features\habits\HabitItem.tsx ##########



########## START PLIK: frontend\features\mood\MoodFormScreen.tsx ##########

import { View, TextInput, TouchableOpacity, ScrollView } from "react-native";
import { useEffect, useState } from "react";
import AppText from "../../components/AppText";
import { useMoodStore, MoodType } from "../../app/stores/useMoodStore";
import { colors, spacing } from "../../constants/theme";
import { useRouter } from "expo-router";
import DateTimePicker from "@react-native-community/datetimepicker";

type Props = {
    editingId?: number;
    initialDate?: string;
};
const moods: MoodType[] = [
    "great",
    "good",
    "neutral",
    "bad",
    "terrible",
];

export default function MoodFormScreen({ editingId, initialDate }: Props) {
    const { entries, addMood, updateMood } = useMoodStore();
    const router = useRouter();

    const existing = entries.find((e) => e.id === editingId);

    const [date, setDate] = useState(
        existing
            ? new Date(existing.date)
            : initialDate
            ? new Date(initialDate)
            : new Date()
        );
    const [time, setTime] = useState(existing ? new Date(`1970-01-01T${existing.time}`) : new Date());

    const [showDatePicker, setShowDatePicker] = useState(false);
    const [showTimePicker, setShowTimePicker] = useState(false);

    const [mood, setMood] = useState<MoodType>(
        existing?.mood || "neutral"
    );
    const [note, setNote] = useState(existing?.note || "");

    useEffect(() => {
        if (existing) {
        setMood(existing.mood);
        setNote(existing.note);
        }
    }, [existing]);

const handleSubmit = async () => {
    const formattedDate = date.toISOString().slice(0, 10);

    const existingForDate = entries.find(
        (e) => e.date === formattedDate
    );

    if (!editingId && existingForDate) {
        alert("Mood already exists for this date");
        return;
    }

    const payload = {
        mood,
        note,
        date: formattedDate,
        time: time.toTimeString().slice(0, 8),
    };

    if (editingId) {
        await updateMood(editingId, payload);
    } else {
        await addMood(payload);
    }

    router.back();
};

return (
  <ScrollView
    contentContainerStyle={{
      padding: spacing.l,
      paddingBottom: 40,
    }}
    keyboardShouldPersistTaps="handled"
  >
    <AppText style={{ fontWeight: "700", marginBottom: 12 }}>
      Select mood
    </AppText>

    <View style={{ flexDirection: "row", flexWrap: "wrap", gap: 10 }}>
      {moods.map((m) => (
        <TouchableOpacity
          key={m}
          onPress={() => setMood(m)}
          style={{
            paddingVertical: 8,
            paddingHorizontal: 14,
            borderRadius: 8,
            backgroundColor:
              mood === m ? colors.buttonActive : colors.card,
          }}
        >
          <AppText>{m}</AppText>
        </TouchableOpacity>
      ))}
    </View>

    {/* DATE + TIME ROW */}
    <View
      style={{
        flexDirection: "row",
        marginTop: spacing.l,
        gap: 12,
      }}
    >
      {/* DATE */}
      <View style={{ flex: 1 }}>
        <AppText>Date</AppText>

        <TouchableOpacity
          onPress={() => setShowDatePicker(true)}
          style={{
            backgroundColor: colors.card,
            padding: 10,
            borderRadius: 8,
            marginTop: spacing.s,
          }}
        >
        <AppText>
        {date.toLocaleDateString("en-En", {
            day: "2-digit",
            month: "short",
            year: "numeric",
        })}
        </AppText>
        </TouchableOpacity>
      </View>

      {/* TIME */}
      <View style={{ flex: 1 }}>
        <AppText>Time</AppText>

        <TouchableOpacity
          onPress={() => setShowTimePicker(true)}
          style={{
            backgroundColor: colors.card,
            padding: 10,
            borderRadius: 8,
            marginTop: spacing.s,
          }}
        >
          <AppText>{time.toTimeString().slice(0, 5)}</AppText>
        </TouchableOpacity>
      </View>
    </View>

    {showDatePicker && (
      <DateTimePicker
        value={date}
        mode="date"
        display="default"
        onChange={(e, selectedDate) => {
          setShowDatePicker(false);
          if (selectedDate) setDate(selectedDate);
        }}
      />
    )}

    {showTimePicker && (
      <DateTimePicker
        value={time}
        mode="time"
        display="default"
        onChange={(e, selectedTime) => {
          setShowTimePicker(false);
          if (selectedTime) setTime(selectedTime);
        }}
      />
    )}

    {/* NOTE */}
    <AppText style={{ marginTop: spacing.l }}>
      Optional note
    </AppText>

    <TextInput
      value={note}
      onChangeText={setNote}
      multiline
      style={{
        marginTop: spacing.s,
        backgroundColor: colors.card,
        padding: 12,
        borderRadius: 8,
        color: colors.text,
        minHeight: 120,
        textAlignVertical: "top",
      }}
    />

    <TouchableOpacity
      onPress={handleSubmit}
      style={{
        marginTop: spacing.l,
        paddingVertical: 14,
        backgroundColor: colors.buttonActive,
        borderRadius: 10,
        alignItems: "center",
      }}
    >
      <AppText>Save</AppText>
    </TouchableOpacity>
  </ScrollView>
);
}

########## KONIEC PLIKU: frontend\features\mood\MoodFormScreen.tsx ##########



########## START PLIK: frontend\features\notes\NoteFormScreen.tsx ##########

import React, { useEffect, useState } from "react";
import {
  View,
  TextInput,
  TouchableOpacity,
  ActivityIndicator,
} from "react-native";
import { useRouter } from "expo-router";
import AppText from "../../components/AppText";
import { colors, radius, spacing } from "../../constants/theme";
import FormErrorModal from "../../components/FormErrorModal";
import { confirmDelete } from "../../components/confirmDelete";
import { useNotesStore } from "../../app/stores/useNotesStore";

export type NoteFormScreenProps = {
  editingId?: number;
};

export default function NoteFormScreen({ editingId }: NoteFormScreenProps) {
  const router = useRouter();

  const {
    fetchById,
    createNote,
    updateNote,
    deleteNote,
  } = useNotesStore();

  const [content, setContent] = useState("");
  const [loading, setLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  useEffect(() => {
    if (!editingId) return;

    const load = async () => {
      setLoading(true);
      const note = await fetchById(editingId);
      if (!note) {
        setErrorMessage("Cannot load note");
      } else {
        setContent(note.content);
      }
      setLoading(false);
    };

    load();
  }, [editingId, fetchById]);

  const save = async () => {
    if (!content.trim()) {
      setErrorMessage("Note cannot be empty");
      return;
    }

    setLoading(true);
    try {
      if (editingId) {
        await updateNote(editingId, content);
      } else {
        await createNote(content);
      }
      router.back();
    } catch (err: any) {
      setErrorMessage(
        err?.response?.data?.detail || "Failed to save note"
      );
    } finally {
      setLoading(false);
    }
  };

  const deleteNoteHandler = async () => {
    if (!editingId) return;

    setLoading(true);
    try {
      await deleteNote(editingId);
      router.back();
    } catch (err: any) {
      setErrorMessage(
        err?.response?.data?.detail || "Failed to delete note"
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <View
        style={{
          flex: 1,
          padding: spacing.m,
          backgroundColor: colors.background,
        }}
      >
        <AppText style={{ fontWeight: "700", marginBottom: spacing.s }}>
          {editingId ? "Edit note" : "New note"}
        </AppText>

        <TextInput
          value={content}
          onChangeText={setContent}
          multiline
          placeholder="Note content..."
          placeholderTextColor="#7a7891"
          selectionColor={colors.buttonActive}
          style={{
            flex: 1,
            backgroundColor: colors.card,
            padding: spacing.m,
            borderRadius: radius.md,
            textAlignVertical: "top",
            color: colors.text,
          }}
        />

        <TouchableOpacity
          onPress={save}
          style={{
            backgroundColor: colors.buttonActive,
            padding: spacing.m,
            borderRadius: radius.md,
            alignItems: "center",
            marginTop: spacing.m,
            marginBottom: editingId ? spacing.s : 0,
          }}
          disabled={loading}
        >
          {loading ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <AppText style={{ color: "#fff", fontWeight: "bold" }}>
              {editingId ? "Save" : "Add note"}
            </AppText>
          )}
        </TouchableOpacity>

        {editingId && (
          <TouchableOpacity
            onPress={() =>
              confirmDelete({
                title: "Delete note?",
                message: "This action cannot be undone.",
                onConfirm: deleteNoteHandler,
              })
            }
            style={{
              backgroundColor: colors.deleteButton,
              padding: spacing.m,
              borderRadius: radius.md,
              alignItems: "center",
            }}
            disabled={loading}
          >
            <AppText style={{ color: "#fff", fontWeight: "bold" }}>
              Delete note
            </AppText>
          </TouchableOpacity>
        )}
      </View>

      <FormErrorModal
        visible={!!errorMessage}
        message={errorMessage || ""}
        onClose={() => setErrorMessage(null)}
      />
    </>
  );
}


########## KONIEC PLIKU: frontend\features\notes\NoteFormScreen.tsx ##########



########## START PLIK: frontend\features\todos\BottomInputBar.tsx ##########

import React from "react";
import { View, TextInput, TouchableOpacity, KeyboardAvoidingView, Platform } from "react-native";
import AppText from "../../components/AppText";
import { colors, radius } from "../../constants/theme";

export default function BottomInputBar({
  quickText,
  setQuickText,
  onOpenDifficulty,
  onQuickAdd
}: any) {
  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === "ios" ? "padding" : "height"}
      keyboardVerticalOffset={Platform.OS === "ios" ? 90 : 0}
      style={{ width: "100%" }}
    >
      <View
        style={{
          flexDirection: "row",
          alignItems: "center",
          padding: 12,
          backgroundColor: colors.background
        }}
      >
        <TouchableOpacity
          onPress={onOpenDifficulty}
          style={{
            padding: 12,
            borderRadius: radius.md,
            backgroundColor: colors.card,
            marginRight: 8,
          }}
        >
          <AppText>D</AppText>
        </TouchableOpacity>

        <TextInput
          value={quickText}
          onChangeText={setQuickText}
          placeholder="Quick add..."
          placeholderTextColor="#7a7891"
          style={{
            flex: 1,
            padding: 12,
            borderRadius: radius.md,
            backgroundColor: colors.card,
            marginRight: 8,
            color: colors.text
          }}
        />

        <TouchableOpacity
          onPress={onQuickAdd}
          style={{
            padding: 12,
            borderRadius: 10,
            backgroundColor: colors.buttonActive
          }}
        >
          <AppText style={{ color: "#fff" }}>+</AppText>
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
}


########## KONIEC PLIKU: frontend\features\todos\BottomInputBar.tsx ##########



########## START PLIK: frontend\features\todos\CategoryFormScreen.tsx ##########

import React, { useEffect, useState } from "react";
import { View, TextInput, TouchableOpacity, ScrollView, ActivityIndicator } from "react-native";
import AppText from "../../components/AppText";
import { colors, spacing, radius } from "../../constants/theme";
import { useRouter } from "expo-router";
import { useTodoStore } from "../../app/stores/useTodoStore";
import FormErrorModal from "../../components/FormErrorModal";
import { confirmDelete } from "../../components/confirmDelete";

export type CategoryFormScreenProps = {
  editingId?: number;
};

export default function CategoryFormScreen({ editingId }: CategoryFormScreenProps) {
  const router = useRouter();
  const isEdit = Boolean(editingId);

  const {
    createCategory,
    saveCategory,
    deleteCategory,
    getCategoryById,
    loadDifficulties,
  } = useTodoStore();

  const [name, setName] = useState("");
  const [difficultyId, setDifficultyId] = useState<number | null>(null);
  const [difficulties, setDifficulties] = useState<any[]>([]);
  const [color, setColor] = useState<string | null>(null);

  const [loading, setLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  const colorPalette = [
    "#908bab",
    "#E5FE86",
    "#825BA5",
    "#83CDEE",
    "#E4BEE6",
    "#EA97DC",
    "#A0B4EF",
  ];

  useEffect(() => {
    const loadMeta = async () => {
      const diffs = await loadDifficulties();
      setDifficulties(diffs);
    };
    loadMeta();
  }, []);

  useEffect(() => {
    if (!editingId) return;

    const load = async () => {
      setLoading(true);
      const c = await getCategoryById(editingId);

      if (!c) {
        setErrorMessage("Failed to load category");
      } else {
        setName(c.name);
        setDifficultyId(c.difficulty?.id || null);
        setColor(c.color || null);
      }

      setLoading(false);
    };

    load();
  }, [editingId]);

  const save = async () => {
    if (!name.trim()) {
      setErrorMessage("Please enter category name");
      return;
    }
    if (!difficultyId) {
      setErrorMessage("Please select difficulty");
      return;
    }

    setLoading(true);

    const payload = {
      name: name.trim(),
      difficulty_id: difficultyId,
      color,
    };

    try {
      if (isEdit && editingId) {
        await saveCategory(editingId, payload);
      } else {
        await createCategory(payload);
      }
      router.back();
    } catch (err: any) {
      setErrorMessage(
        err?.response?.data?.detail || "Failed to save category"
      );
    }
    finally {
      setLoading(false);
    }
  };

  const deleteHandler = async () => {
    if (!editingId) return;

    setLoading(true);
    try {
      await deleteCategory(editingId);
      router.back();
    } catch (err: any) {
      setErrorMessage(
        err?.response?.data?.detail || "Failed to delete category"
      );
    }
    finally {
      setLoading(false);
    }
  };

  return (
    <>
      <ScrollView
        style={{ flex: 1, padding: spacing.m, backgroundColor: colors.background }}
        contentContainerStyle={{ paddingBottom: 30 }}
      >
        <AppText style={{ marginBottom: 6 }}>Name:</AppText>
        <TextInput
          value={name}
          onChangeText={setName}
          editable={!loading}
          placeholder="Category name"
          placeholderTextColor="#7a7891"
          style={{
            borderWidth: 1,
            borderColor: colors.inputBorder,
            color: colors.text,
            padding: spacing.s,
            borderRadius: radius.md,
            marginBottom: spacing.m,
          }}
        />

        <AppText style={{ marginBottom: 6 }}>Color:</AppText>
        <View style={{ flexDirection: "row", marginBottom: spacing.m }}>
          {colorPalette.map(c => (
            <TouchableOpacity
              key={c}
              disabled={loading}
              onPress={() => setColor(c)}
              style={{
                width: 36,
                height: 36,
                borderRadius: 8,
                backgroundColor: c,
                marginRight: 8,
                borderWidth: color === c ? 2 : 0,
                borderColor: "#fff",
              }}
            />
          ))}
        </View>

        <AppText style={{ marginBottom: 6 }}>Difficulty:</AppText>
        <View style={{ flexDirection: "row", flexWrap: "wrap", marginBottom: spacing.m }}>
          {difficulties.map(d => (
            <TouchableOpacity
              key={d.id}
              disabled={loading}
              onPress={() => setDifficultyId(d.id)}
              style={{
                padding: spacing.s,
                borderRadius: radius.md,
                marginRight: spacing.s,
                marginBottom: spacing.s,
                backgroundColor:
                  difficultyId === d.id ? colors.buttonActive : colors.button,
              }}
            >
              <AppText>{d.name}</AppText>
            </TouchableOpacity>
          ))}
        </View>

        <TouchableOpacity
          disabled={loading}
          onPress={save}
          style={{
            backgroundColor: colors.buttonActive,
            padding: spacing.m,
            borderRadius: radius.md,
            alignItems: "center",
            marginBottom: isEdit ? spacing.m : 0,
          }}
        >
          {loading ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <AppText style={{ color: "#fff", fontWeight: "bold" }}>
              {isEdit ? "Save" : "Add category"}
            </AppText>
          )}
        </TouchableOpacity>

        {isEdit && (
          <TouchableOpacity
            disabled={loading}
            onPress={() =>
              confirmDelete({
                title: "Delete category?",
                message: "All tasks in this category will be deleted.",
                onConfirm: deleteHandler,
              })
            }
            style={{
              backgroundColor: colors.deleteButton,
              padding: spacing.m,
              borderRadius: radius.md,
              alignItems: "center",
            }}
          >
            <AppText style={{ color: "#fff", fontWeight: "bold" }}>
              Delete category
            </AppText>
          </TouchableOpacity>
        )}
      </ScrollView>

      <FormErrorModal
        visible={!!errorMessage}
        message={errorMessage || ""}
        onClose={() => setErrorMessage(null)}
      />
    </>
  );
}


########## KONIEC PLIKU: frontend\features\todos\CategoryFormScreen.tsx ##########



########## START PLIK: frontend\features\todos\TodoItem.tsx ##########

import React, { useRef } from "react";
import { View, Alert, Pressable, StyleSheet } from "react-native";
import { Swipeable } from "react-native-gesture-handler";
import AppText from "../../components/AppText";
import { components, spacing, colors } from "../../constants/theme";
import { useModuleSettingsStore } from "../../app/stores/useModuleSettingsStore";

export default function TodoItem({ item, onComplete, onDelete, onLongPress }: any) {
  const swipeRef = useRef<Swipeable>(null);
  const isCompleted = item.is_completed;

  const { modules } = useModuleSettingsStore();
  const gamificationOn = modules?.gamification;

  const confirmComplete = () => {
    swipeRef.current?.close();
    Alert.alert(
      "Complete task?",
      item.content,
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Yes",
          onPress: () => onComplete(item.id),
        },
      ]
    );
  };

  const confirmDelete = () => {
    swipeRef.current?.close();
    Alert.alert(
      "Delete task?",
      item.content,
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Delete",
          style: "destructive",
          onPress: () => onDelete(item.id),
        },
      ]
    );
  };

  const renderLeftAction = () => (
    <View style={[styles.action, styles.complete]}>
      <AppText style={styles.actionText}>Complete</AppText>
    </View>
  );

  const renderRightAction = () => (
    <View style={[styles.action, styles.delete]}>
      <AppText style={styles.actionText}>Delete</AppText>
    </View>
  );

  return (
    <Swipeable
      ref={swipeRef}
      renderLeftActions={!isCompleted ? renderLeftAction : undefined}
      renderRightActions={renderRightAction}
      leftThreshold={60}
      rightThreshold={60}
      onSwipeableLeftOpen={!isCompleted ? confirmComplete : undefined}
      onSwipeableRightOpen={confirmDelete}
      overshootFriction={6}
    >
      <Pressable
        onLongPress={onLongPress}
        style={({ pressed }) => [
          styles.container,
          { opacity: pressed ? 0.9 : 1 },
        ]}
      >
        <View style={{ flexDirection: "row", alignItems: "center" }}>
          <View style={{ flexDirection: "row", alignItems: "center", justifyContent: "space-between" }}>
            <View style={{ flex: 1, marginRight: 10 }}>
              <AppText
                style={{
                  textDecorationLine: isCompleted ? "line-through" : "none",
                  color: isCompleted ? "#777" : colors.text,
                }}
              >
                {item.content}
              </AppText>
            </View>

            {gamificationOn && item.custom_difficulty && (
              <AppText
                style={{
                  fontWeight: "normal",
                  color: isCompleted ? "#777" : colors.light,
                  textAlign: "right",
                }}
              >
                ({item.custom_difficulty.name})
              </AppText>
            )}
          </View>
        </View>
      </Pressable>
    </Swipeable>
  );
}

const styles = StyleSheet.create({
  container: {
    ...components.container,
    marginBottom: spacing.s,
    marginHorizontal: 12,
    paddingVertical: 10,
    paddingHorizontal: 14,
  },
  action: {
    justifyContent: "center",
    alignItems: "center",
    width: 96,
    marginVertical: spacing.s,
    borderRadius: 10,
  },
  complete: {
    backgroundColor: colors.buttonActive,
  },
  delete: {
    backgroundColor: "#d9534f",
  },
  actionText: {
    color: "#fff",
    fontWeight: "700",
  },
});


########## KONIEC PLIKU: frontend\features\todos\TodoItem.tsx ##########



########## START PLIK: frontend\features\todos\customDifficultyPicker.tsx ##########

import React, { useEffect, useState } from "react";
import { View, TouchableOpacity, Modal, ScrollView, Alert } from "react-native";
import AppText from "../../components/AppText";
import { colors } from "../../constants/theme";
import { api } from "../../app/api/apiClient";

export default function CustomDifficultyPicker({ onSelect, onClose }) {
  const [difficulties, setDifficulties] = useState([]);

  useEffect(() => {
    (async () => {
      const res = await api.get("/common/difficulties/");
      setDifficulties(res.data);
    })();
  }, []);

  return (
    <Modal transparent animationType="fade" visible>
      <View style={{
        flex: 1,
        backgroundColor: "rgba(0,0,0,0.4)",
        justifyContent: "center",
        alignItems: "center",
        padding: 20
      }}>
        
        <View style={{
          width: "80%",
          maxHeight: "80%",
          backgroundColor: colors.card,
          borderRadius: 14,
          padding: 16
        }}>
          <AppText style={{ marginBottom: 12, fontWeight: "bold", fontSize: 18 }}>
            Choose difficulty
          </AppText>

          <ScrollView>
            {difficulties.map(d => (
              <TouchableOpacity
                key={d.id}
                onPress={() => onSelect(d)}
                style={{
                  padding: 12,
                  borderRadius: 8,
                  marginBottom: 8,
                  backgroundColor: colors.light,
                }}
              >
                <AppText>{d.name}</AppText>
              </TouchableOpacity>

            ))}
          </ScrollView>

          <TouchableOpacity
            onPress={onClose}
            style={{
              marginTop: 16,
              padding: 12,
              borderRadius: 10,
              backgroundColor: colors.buttonActive,
              alignItems: "center",
            }}
          >
            <AppText style={{ color: "#fff" }}>Close</AppText>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
}


########## KONIEC PLIKU: frontend\features\todos\customDifficultyPicker.tsx ##########



########## START PLIK: frontend\features\todos\editTodoPopup.tsx ##########

import React, { useState } from "react";
import { View, Modal, TouchableOpacity, TextInput } from "react-native";
import AppText from "../../components/AppText";
import { colors } from "../../constants/theme";
import CustomDifficultyPicker from "./customDifficultyPicker";
import { confirmDelete } from "../../components/confirmDelete";
import { useTodoStore } from "../../app/stores/useTodoStore";

export default function EditTodoPopup({ item, onClose }: any) {
  const { updateTask, deleteTask } = useTodoStore();

  const [content, setContent] = useState(item.content);
  const [difficulty, setDifficulty] = useState(item.custom_difficulty || null);
  const [showDifficulty, setShowDifficulty] = useState(false);
  const [loading, setLoading] = useState(false);

  const save = async () => {
    if (!content.trim()) return;

    setLoading(true);
    try {
      await updateTask(item.id, {
        content: content.trim(),
        custom_difficulty_id: difficulty?.id || null,
      });
      onClose();
    } finally {
      setLoading(false);
    }
  };

  const deleteHandler = () => {
    confirmDelete({
      title: "Delete task?",
      message: item.content,
      onConfirm: async () => {
        setLoading(true);
        try {
          await deleteTask(item.id);
          onClose();
        } finally {
          setLoading(false);
        }
      },
    });
  };

  const buttonStyle = {
    padding: 12,
    borderRadius: 10,
    marginBottom: 12,
    alignItems: "center" as const,
    opacity: loading ? 0.6 : 1,
  };

  return (
    <Modal transparent animationType="fade" visible>
      {showDifficulty && (
        <CustomDifficultyPicker
          onSelect={(d) => {
            setDifficulty(d);
            setShowDifficulty(false);
          }}
          onClose={() => setShowDifficulty(false)}
        />
      )}

      <View
        style={{
          flex: 1,
          backgroundColor: "rgba(0,0,0,0.4)",
          justifyContent: "center",
          alignItems: "center",
          padding: 20,
        }}
      >
        <View
          style={{
            width: "85%",
            backgroundColor: colors.card,
            borderRadius: 14,
            padding: 16,
          }}
        >
          <AppText style={{ fontWeight: "bold", fontSize: 18, marginBottom: 12 }}>
            Edit task
          </AppText>

          <TextInput
            value={content}
            onChangeText={setContent}
            editable={!loading}
            placeholder="Task content"
            placeholderTextColor="#777"
            style={{
              backgroundColor: colors.background,
              padding: 12,
              borderRadius: 10,
              marginBottom: 16,
              color: colors.text,
            }}
          />

          <TouchableOpacity
            disabled={loading}
            onPress={() => setShowDifficulty(true)}
            style={{
              ...buttonStyle,
              backgroundColor: colors.buttonActive,
            }}
          >
            <AppText style={{ color: "#fff" }}>
              {difficulty ? difficulty.name : "Set difficulty"}
            </AppText>
          </TouchableOpacity>

          <TouchableOpacity
            disabled={loading}
            onPress={deleteHandler}
            style={{
              ...buttonStyle,
              backgroundColor: colors.buttonActive,
            }}
          >
            <AppText style={{ color: "#fff" }}>Delete task</AppText>
          </TouchableOpacity>

          <TouchableOpacity
            disabled={loading}
            onPress={save}
            style={{
              ...buttonStyle,
              backgroundColor: colors.buttonActive,
            }}
          >
            <AppText style={{ color: "#fff" }}>Save</AppText>
          </TouchableOpacity>

          <TouchableOpacity
            disabled={loading}
            onPress={onClose}
            style={{
              ...buttonStyle,
              backgroundColor: colors.buttonActive,
              marginBottom: 0,
            }}
          >
            <AppText style={{ color: "#fff" }}>Cancel</AppText>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
}


########## KONIEC PLIKU: frontend\features\todos\editTodoPopup.tsx ##########



########## START PLIK: frontend\app\(tabs)\ChallengesListScreen.tsx ##########

import React, { useCallback, useEffect, useMemo, useState } from "react";
import { View, TouchableOpacity, SectionList, ScrollView } from "react-native";
import { useChallengeStore } from "../stores/useChallengeStore";
import ChallengeItem from "../../features/challenges/ChallengeItem";
import { useFocusEffect, useRouter } from "expo-router";
import AppText from "../../components/AppText";
import { colors, radius } from "../../constants/theme";
import FloatingButton from "../../components/FloatingButton";

const ChallengesListScreen = () => {
  const router = useRouter();

  const TYPES = [
    { label: "Daily", value: "daily" },
    { label: "Weekly", value: "weekly" },
  ] as const;

  const {
    challenges,
    tags,
    activeDaily,
    activeWeekly,
    selectedType,
    setSelectedType,
    loading,
    loadTags,
    loadChallenges,
    fetchActive,
  } = useChallengeStore();

  const [selectedTags, setSelectedTags] = useState<number[]>([]);
  const [showAll, setShowAll] = useState(false);

    useEffect(() => {
    loadTags();
    loadChallenges();
  }, []);


  useFocusEffect(
  useCallback(() => {
    fetchActive();
  }, [])
);

  const toggleTag = (id: number) => {
    setSelectedTags((prev) =>
      prev.includes(id) ? prev.filter((x) => x !== id) : [...prev, id]
    );
  };

  const activeChallenges = useMemo(() => {
    if (selectedType === "daily") {
      return activeDaily ? [activeDaily] : [];
    }
    return activeWeekly;
  }, [activeDaily, activeWeekly, selectedType]);

  const activeDefinitionIds = new Set(
    activeChallenges.map((uc) => uc.challenge.id)
  );

  const filteredChallenges = useMemo(() => {
    return challenges.filter((c) => {
      if (c.type.name !== selectedType) return false;
      if (activeDefinitionIds.has(c.id)) return false;
      if (
        selectedTags.length > 0 &&
        !selectedTags.some((tid) => c.tags.some((t) => t.id === tid))
      )
        return false;
      return true;
    });
  }, [challenges, selectedType, selectedTags, activeDefinitionIds]);

  let sections: any[] = [];

  if (activeChallenges.length > 0) {
    sections.push({
      title: "Actual challenge",
      data: activeChallenges,
      isUserChallenge: true,
    });

    if (filteredChallenges.length > 0) {
      sections.push({
        title: "Challenges list",
        data: showAll ? filteredChallenges : [],
        isUserChallenge: false,
      });
    }
  } else if (filteredChallenges.length > 0) {
    sections.push({
      title: "Challenges list",
      data: filteredChallenges,
      isUserChallenge: false,
    });
  }


  return (
    <View style={{ flex: 1, padding: 10, backgroundColor: colors.background }}>
      <View style={{ flexDirection: "row", marginBottom: 10 }}>
        {TYPES.map(({ label, value }, i) => (
          <TouchableOpacity
            key={value}
            onPress={() => setSelectedType(value)}
            style={{
              flex: 1,
              padding: 15,
              marginRight: i === 0 ? 5 : 0,
              marginLeft: i === 1 ? 5 : 0,
              borderRadius: radius.md,
              backgroundColor:
                selectedType === value
                  ? colors.buttonActive
                  : colors.button,
              alignItems: "center",
              justifyContent: "center",
            }}
          >
            <AppText style={{ color: colors.text, fontWeight: "bold" }}>
              {label}
            </AppText>
          </TouchableOpacity>
        ))}
      </View>
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        style={{ marginBottom: 10, height: 85, flexGrow: 0 }}
        contentContainerStyle={{
          alignItems: "flex-start",
          paddingLeft: 0,
          paddingRight: 5,
          paddingBottom: 20,
        }}
      >
        {!loading.meta &&
          tags.map((tag) => (
            <TouchableOpacity
              key={tag.id}
              onPress={() => toggleTag(tag.id)}
              onLongPress={() => router.push(`/editTag/${tag.id}`)}
              delayLongPress={300}
              style={{
                paddingVertical: 8,
                paddingHorizontal: 12,
                marginRight: 5,
                borderRadius: radius.md,
                backgroundColor: selectedTags.includes(tag.id)
                  ? colors.buttonActive
                  : colors.button,
              }}
            >
              <AppText style={{ color: colors.text }}>{tag.name}</AppText>
            </TouchableOpacity>
          ))}

        <TouchableOpacity
          onPress={() => router.push("/addTag")}
          style={{
            width: 34,
            height: 34,
            borderRadius: 20,
            backgroundColor: colors.buttonActive,
            justifyContent: "center",
            alignItems: "center",
          }}
        >
          <AppText style={{ fontSize: 24, color: "#fff" }}>+</AppText>
        </TouchableOpacity>
      </ScrollView>
      {!loading.list && challenges.length === 0 ? (
        <View
          style={{
            flex: 1,
            justifyContent: "center",
            alignItems: "center",
            marginTop: 50,
          }}
        >
          <AppText style={{ color: "#777", fontSize: 16 }}>
            No challenges yet, add some!
          </AppText>
        </View>
      ) : !loading.list && sections.length === 0 ? (
        <View
          style={{
            flex: 1,
            justifyContent: "center",
            alignItems: "center",
            marginTop: 50,
          }}
        >
          <AppText style={{ color: "#777", fontSize: 16 }}>
            No challenges with those tags
          </AppText>
        </View>
      ) : (
        <SectionList
          sections={sections}
          keyExtractor={(item) => item.id.toString()}
          renderItem={({ item, section }) => (
            <ChallengeItem
              item={item}
              isUserChallenge={section.isUserChallenge}
            />
          )}
          renderSectionHeader={({ section: { title } }) => {
            const isExpandable = title === "Challenges list";
            return (
              <TouchableOpacity
                onPress={() => {
                  if (isExpandable) setShowAll((prev) => !prev);
                }}
                style={{ marginVertical: 10 }}
              >
                <AppText
                  style={{
                    fontSize: 17,
                    fontWeight: "bold",
                    color: colors.text,
                  }}
                >
                  {title}
                </AppText>
              </TouchableOpacity>
            );
          }}
          contentContainerStyle={{ paddingBottom: 100 }}
        />
      )}

      <FloatingButton
        onPress={() =>
          router.push({
            pathname: "/addChallenge",
            params: { type: selectedType },
          })
        }
      />
    </View>
  );
};

export default ChallengesListScreen;


########## KONIEC PLIKU: frontend\app\(tabs)\ChallengesListScreen.tsx ##########



########## START PLIK: frontend\app\(tabs)\GamificationScreen.tsx ##########

import React, { useCallback, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  Platform,
  UIManager,
} from "react-native";
import { useFocusEffect } from "@react-navigation/native";
import Svg, { Circle } from "react-native-svg";
import { colors, spacing } from "../../constants/theme";
import { api } from "../api/apiClient";
import { useGamificationStore } from "../stores/useGamificationStore";

if (Platform.OS === "android" && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const SIZE = 180;
const STROKE_WIDTH = 9;

export default function GamificationScreen() {

  const { totalXp, currentLevel: level, fetchUser } =
    useGamificationStore();

  useFocusEffect(
    useCallback(() => {
      fetchUser();
      fetchLogs();
    }, [])
  );

  const [xpLogs, setXpLogs] = useState<any[]>([]);

  const fetchLogs = async () => {
    try {
      const res = await api.get("/gamification/me/");
      const sorted = (res.data.logs || []).sort(
        (a, b) =>
          new Date(b.created_at).getTime() -
          new Date(a.created_at).getTime()
      );
      setXpLogs(sorted);
    } catch (e) {
      console.log("fetchLogs error", e);
    }
  };

  const xpForLevel = (lvl: number) => 50 * lvl * (lvl - 1);
  const currentLevelXpStart = xpForLevel(level);
  const nextLevelXp = xpForLevel(level + 1);
  const xpIntoLevel = totalXp - currentLevelXpStart;
  const xpNeededForNext = nextLevelXp - currentLevelXpStart;
  const progress = Math.min(xpIntoLevel / xpNeededForNext, 1);

  const radiusCircle = (SIZE - STROKE_WIDTH) / 2;
  const circumference = 2 * Math.PI * radiusCircle;
  const strokeDashoffset = circumference * (1 - progress);

  return (
    <View style={styles.container}>
      <View style={{ marginBottom: spacing.l }}>
        <Svg width={SIZE} height={SIZE}>
          <Circle
            cx={SIZE / 2}
            cy={SIZE / 2}
            r={radiusCircle}
            stroke={colors.card}
            strokeWidth={STROKE_WIDTH}
          />
          <Circle
            cx={SIZE / 2}
            cy={SIZE / 2}
            r={radiusCircle}
            stroke={colors.buttonActive}
            strokeWidth={STROKE_WIDTH}
            strokeDasharray={`${circumference} ${circumference}`}
            strokeDashoffset={strokeDashoffset}
            strokeLinecap="round"
            rotation="-90"
            originX={SIZE / 2}
            originY={SIZE / 2}
          />
        </Svg>

        <View style={[StyleSheet.absoluteFillObject, styles.levelTextContainer]}>
          <Text style={styles.levelText}>{level}</Text>
          <Text style={styles.totalXpText}>{totalXp} XP</Text>
        </View>
      </View>

      <Text style={{ marginBottom: spacing.m, color: colors.text }}>
        Left to the next level: {xpNeededForNext - xpIntoLevel} XP
      </Text>

      <FlatList
        style={{ marginTop: spacing.l, width: "100%" }}
        data={xpLogs.slice(0, 20)}
        keyExtractor={(item) => item.id.toString()}
        ListEmptyComponent={() => (
          <Text style={{ color: "#777", textAlign: "center", marginTop: 20 }}>
            No XP activity yet
          </Text>
        )}
        renderItem={({ item }) => (
          <View style={styles.logItem}>
            <Text style={{ color: colors.text }}>
              +{item.xp} XP • {item.source}
            </Text>
            <Text style={{ fontSize: 10, color: "#777" }}>
              {new Date(item.created_at).toLocaleString()}
            </Text>
          </View>
        )}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background,
    alignItems: "center",
    padding: spacing.m,
  },
  levelTextContainer: {
    justifyContent: "center",
    alignItems: "center",
  },
  levelText: {
    fontSize: 50,
    fontWeight: "bold",
    color: colors.text,
  },
  totalXpText: {
    fontSize: 18,
    color: colors.text,
    marginTop: 5,
  },
  logItem: {
    padding: spacing.s,
    borderBottomWidth: 1,
    borderBottomColor: "#ccc",
  },
});


########## KONIEC PLIKU: frontend\app\(tabs)\GamificationScreen.tsx ##########



########## START PLIK: frontend\app\(tabs)\GoalsScreen.tsx ##########

import React, { useCallback, useEffect, useState } from "react";
import { View, TouchableOpacity, FlatList, Alert, ActivityIndicator } from "react-native";
import AppText from "../../components/AppText";
import { colors } from "../../constants/theme";
import { useGoalStore } from "../stores/useGoalStore";
import { useFocusEffect, useRouter } from "expo-router";
import dayjs from "dayjs";
import isoWeek from "dayjs/plugin/isoWeek";
import { useModuleSettingsStore } from "../stores/useModuleSettingsStore";
import { useGamificationStore } from "../stores/useGamificationStore";
import FloatingButton from "../../components/FloatingButton";
import GoalItem from "../../features/goals/GoalItem";

dayjs.extend(isoWeek);

const periodNames = ["weekly", "monthly", "yearly"] as const;
type Period = typeof periodNames[number];

export default function GoalsScreen() {
  const router = useRouter();

  const { modules } = useModuleSettingsStore();
  const gamificationOn = modules?.gamification;

  const {
    goals,
    loading,
    loadPeriods,
    loadGoals,
    completeGoal,
  } = useGoalStore();

  const [expandedGoalId, setExpandedGoalId] = useState<number | null>(null);
  const [selectedPeriod, setSelectedPeriod] = useState<Period>("weekly");

  useEffect(() => {
    loadPeriods();
  }, []);

  useFocusEffect(
    useCallback(() => {
      loadGoals(selectedPeriod);
    }, [selectedPeriod])
  );

  const completedCount = goals.filter(g => g.is_completed).length;
  const progress = goals.length === 0 ? 0 : completedCount / goals.length;
  
  const now = dayjs();
  const timeProgress =
    selectedPeriod === "weekly"
      ? now.diff(now.startOf("isoWeek")) /
        now.endOf("isoWeek").diff(now.startOf("isoWeek"))
      : selectedPeriod === "monthly"
      ? now.diff(now.startOf("month")) /
        now.endOf("month").diff(now.startOf("month"))
      : now.diff(now.startOf("year")) /
        now.endOf("year").diff(now.startOf("year"));

  const onComplete = (goalId: number, title: string) => {
    Alert.alert("Complete goal?", title, [
      { text: "Cancel", style: "cancel" },
      {
        text: "Yes",
        onPress: async () => {
          const res = await completeGoal(goalId);

          if (res && gamificationOn && res.xp_gained > 0) {
            useGamificationStore.getState().applyXpResult(res);
          }

          loadGoals(selectedPeriod);
        },
      },
    ]);
  };


  return (
    <View style={{ flex: 1, padding: 12, backgroundColor: colors.background }}>

      <View style={{ flexDirection: "row", marginBottom: 12 }}>
        {periodNames.map(p => (
          <TouchableOpacity
            key={p}
            onPress={() => setSelectedPeriod(p)}
            style={{
              flex: 1,
              marginHorizontal: 4,
              padding: 14,
              borderRadius: 12,
              backgroundColor:
                selectedPeriod === p ? colors.buttonActive : colors.card,
              alignItems: "center",
            }}
          >
            <AppText style={{ fontWeight: "bold", textTransform: "capitalize" }}>
              {p}
            </AppText>
          </TouchableOpacity>
        ))}
      </View>

      <View
        style={{
          backgroundColor: colors.card,
          borderRadius: 12,
          padding: 10,
          marginBottom: 12,
        }}
      >
        <AppText style={{ fontSize: 12 }}>
          Goals progress: {Math.round(progress * 100)}%
        </AppText>
        <View
          style={{
            height: 6,
            backgroundColor: colors.background,
            borderRadius: 4,
            marginBottom: 8,
          }}
        >
          <View
            style={{
              height: 6,
              width: `${progress * 100}%`,
              backgroundColor: colors.buttonActive,
            }}
          />
        </View>

        <AppText style={{ fontSize: 12 }}>
          Time ({selectedPeriod}): {Math.round(timeProgress * 100)}%
        </AppText>
        <View
          style={{
            height: 6,
            backgroundColor: colors.background,
            borderRadius: 4,
          }}
        >
          <View
            style={{
              height: 6,
              width: `${timeProgress * 100}%`,
              backgroundColor: colors.buttonActive,
            }}
          />
        </View>
      </View>

      {loading.list ? (
        <View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}>
          <ActivityIndicator size="large" color={colors.buttonActive} />
        </View>
      ) : goals.length === 0 ? (
        <View style={{ alignItems: "center", marginTop: 50 }}>
          <AppText style={{ color: "#777" }}>
            no goals yet for this period
          </AppText>
        </View>
      ) : (
 <FlatList
          key={selectedPeriod}
          data={goals}
          keyExtractor={(item) => item.id.toString()}
          contentContainerStyle={{ paddingBottom: 140 }}
          renderItem={({ item }) => (
            <GoalItem
              item={item}
              isCompleted={item.is_completed}
              isExpanded={expandedGoalId === item.id}
              onToggleExpand={() =>
                setExpandedGoalId(
                  expandedGoalId === item.id ? null : item.id
                )
              }
              onEdit={() => router.push(`/editGoal/${item.id}`)}
              onComplete={() => onComplete(item.id, item.title)}
            />
          )}
        />
      )}

      <FloatingButton onPress={() => router.push("/addGoal")} />
    </View>
  );
}

########## KONIEC PLIKU: frontend\app\(tabs)\GoalsScreen.tsx ##########



########## START PLIK: frontend\app\(tabs)\HabitsScreen.tsx ##########

import React, { useEffect, useState } from "react";
import {
  View,
  TouchableOpacity,
  FlatList,
  Alert,
  ActivityIndicator,
} from "react-native";
import { useHabitStore } from "../stores/useHabitStore";
import AppText from "../../components/AppText";
import { colors } from "../../constants/theme";
import { useRouter } from "expo-router";
import HabitItem from "../../features/habits/HabitItem";
import { useModuleSettingsStore } from "../stores/useModuleSettingsStore";
import { useGamificationStore } from "../stores/useGamificationStore";
import FloatingButton from "../../components/FloatingButton";

export default function HabitsScreen() {
  const router = useRouter();

  const { modules } = useModuleSettingsStore();
  const gamificationOn = modules?.gamification;

  const {
    habits,
    loading,
    loadMonth,
    loadDifficulties,
    toggleDay,
  } = useHabitStore();

  const [month, setMonth] = useState<string | undefined>(undefined);

  useEffect(() => {
    loadDifficulties();
  }, []);

  useEffect(() => {
    loadMonth(month);
  }, [month]);

  const onToggleToday = async (habitId: number) => {
    const today = new Date().toISOString().slice(0, 10);
    const res = await toggleDay(habitId, today);

    if (!res) {
      Alert.alert("Error", "Cannot save day.");
      return;
    }

    if (res.already_completed) {
      if (gamificationOn) {
        Alert.alert("Info", "This habit was already marked for today.");
      }
    } else if (res.xp_gained > 0 && gamificationOn) {
      useGamificationStore.getState().applyXpResult(res);
    }

    await loadMonth(month, { silent: true });
  };

  const onToggleDay = async (
    habitId: number,
    date: string,
    newStatus: number
  ) => {
    const res = await toggleDay(habitId, date, newStatus);

    if (!res) {
      Alert.alert("Error", "Cannot save day");
      return;
    }

    if (res.xp_gained > 0 && gamificationOn) {
      useGamificationStore.getState().applyXpResult(res);
    }

    await loadMonth(month, { silent: true });
  };


  return (
    <View
      style={{
        flex: 1,
        padding: 12,
        backgroundColor: colors.background,
      }}
    >

      <View
        style={{
          flexDirection: "row",
          justifyContent: "space-between",
          marginBottom: 12,
        }}
      >
        <TouchableOpacity
          onPress={() => {
            const base = month
              ? new Date(month + "-01")
              : new Date();
            base.setMonth(base.getMonth() - 1);
            setMonth(
              `${base.getFullYear()}-${(base.getMonth() + 1)
                .toString()
                .padStart(2, "0")}`
            );
          }}
          style={{ padding: 8 }}
        >
          <AppText>{"<"}</AppText>
        </TouchableOpacity>

        <AppText>
          {month ?? new Date().toISOString().slice(0, 7)}
        </AppText>

        <TouchableOpacity
          onPress={() => {
            const base = month
              ? new Date(month + "-01")
              : new Date();
            base.setMonth(base.getMonth() + 1);
            setMonth(
              `${base.getFullYear()}-${(base.getMonth() + 1)
                .toString()
                .padStart(2, "0")}`
            );
          }}
          style={{ padding: 8 }}
        >
          <AppText>{">"}</AppText>
        </TouchableOpacity>
      </View>

      {loading.list ? (
        <View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}>
          <ActivityIndicator size="large" color={colors.buttonActive} />
        </View>
      ) : habits.length === 0 ? (
        <View
          style={{
            flex: 1,
            justifyContent: "center",
            alignItems: "center",
            marginTop: 50,
          }}
        >
          <AppText style={{ color: "#777", fontSize: 16 }}>
            no habits yet, add some!
          </AppText>
        </View>
      ) : (
        <FlatList
          data={habits}
          keyExtractor={(item) => item.id.toString()}
          renderItem={({ item }) => (
            <HabitItem
              item={item}
              onToggleToday={onToggleToday}
              onToggleDay={onToggleDay}
            />
          )}
          contentContainerStyle={{ paddingBottom: 140 }}
        />
      )}

      <FloatingButton onPress={() => router.push("/addHabit")} />
    </View>
  );
}


########## KONIEC PLIKU: frontend\app\(tabs)\HabitsScreen.tsx ##########



########## START PLIK: frontend\app\(tabs)\MoodScreen.tsx ##########

import { View, TouchableOpacity, ScrollView } from "react-native";
import { useEffect } from "react";
import { useMoodStore } from "../stores/useMoodStore";
import { colors, spacing } from "../../constants/theme";
import FloatingButton from "../../components/FloatingButton";
import { useRouter } from "expo-router";
import AppText from "../../components/AppText";

const CELL_SIZE = 18;
const CELL_MARGIN = 2;
const DAY_LABEL_WIDTH = 28;
const HEADER_HEIGHT = 40;

const moodColors = {
  great: "#F9A44A",
  good: "#77C092",
  neutral: "#A678B6",
  bad: "#7795B9",
  terrible: "#949DA2",
};

const monthShort = [
  "Jan","Feb","Mar","Apr","May","Jun",
  "Jul","Aug","Sep","Oct","Nov","Dec"
];

export default function MoodScreen() {
  const { entries, fetchYear } = useMoodStore();
  const router = useRouter();
  const year = new Date().getFullYear();

  useEffect(() => {
    fetchYear(year);
  }, []);

  const daysInMonth = (year: number, month: number) =>
    new Date(year, month + 1, 0).getDate();

  return (
    <View style={{ flex: 1 }}>
      <ScrollView>
        <ScrollView horizontal>
          <View style={{ padding: spacing.m }}>
{/* HEADER */}
<View style={{ flexDirection: "row", height: 60 }}>
  <View style={{ width: DAY_LABEL_WIDTH }} />

  {monthShort.map((m) => (
    <View
      key={m}
      style={{
        width: CELL_SIZE + CELL_MARGIN * 2,
        alignItems: "center",
        justifyContent: "flex-end",
      }}
    >
      {m.split("").map((letter, i) => (
        <AppText
          key={i}
          style={{
            fontSize: 9,
            lineHeight: 10,
          }}
        >
          {letter}
        </AppText>
      ))}
    </View>
  ))}
</View>

            {/* GRID */}
            {[...Array(31)].map((_, dayIndex) => {
              const day = dayIndex + 1;

              return (
                <View
                  key={day}
                  style={{ flexDirection: "row", alignItems: "center" }}
                >
                  {/* DAY LABEL */}
                  <View
                    style={{
                      width: DAY_LABEL_WIDTH,
                      alignItems: "flex-end",
                      paddingRight: 4,
                    }}
                  >
                    <AppText style={{ fontSize: 10 }}>
                      {day}
                    </AppText>
                  </View>

                  {monthShort.map((_, monthIndex) => {
                    if (day > daysInMonth(year, monthIndex)) {
                      return (
                        <View
                          key={monthIndex}
                          style={{
                            width: CELL_SIZE,
                            height: CELL_SIZE,
                            margin: CELL_MARGIN,
                          }}
                        />
                      );
                    }

                    const dateStr = `${year}-${String(monthIndex + 1).padStart(2, "0")}-${String(day).padStart(2, "0")}`;
                    const entry = entries.find(
                      (e) => e.date === dateStr
                    );

                    return (
                      <TouchableOpacity
                        key={monthIndex}
                        onPress={() =>
                          entry
                            ? router.push(`/editMood/${entry.id}`)
                            : router.push({
                                pathname: "/addMood",
                                params: { date: dateStr },
                              })
                        }
                        style={{
                          width: CELL_SIZE,
                          height: CELL_SIZE,
                          margin: CELL_MARGIN,
                          borderRadius: 3,
                          backgroundColor: entry
                            ? moodColors[entry.mood]
                            : colors.card,
                        }}
                      />
                    );
                  })}
                </View>
              );
            })}
          </View>
        </ScrollView>
      </ScrollView>

      <FloatingButton
        onPress={() => router.push("/addMood")}
      />
    </View>
  );
}

########## KONIEC PLIKU: frontend\app\(tabs)\MoodScreen.tsx ##########



########## START PLIK: frontend\app\(tabs)\RandomHomeScreen.tsx ##########

import React from "react";
import { View, TouchableOpacity } from "react-native";
import AppText from "../../components/AppText";
import { colors } from "../../constants/theme";
import { useRouter } from "expo-router";
import { useChallengeStore } from "../stores/useChallengeStore";
import { useModuleSettingsStore } from "../stores/useModuleSettingsStore";

export default function RandomHomeScreen() {
  const router = useRouter();

  const { activeDaily, activeWeekly } = useChallengeStore();
  const { modules } = useModuleSettingsStore();

  const handleDaily = () => {
    router.push(
      activeDaily ? "/random/daily/active" : "/random/daily"
    );
  };

  const handleWeekly = () => {
    router.push(
      activeWeekly.length > 0
        ? "/random/weekly/active"
        : "/random/weekly"
    );
  };

  return (
    <View
      style={{
        flex: 1,
        padding: 16,
        backgroundColor: colors.background,
        justifyContent: "center",
      }}
    >
      <TouchableOpacity
        onPress={modules?.challenges ? handleDaily : undefined}
        style={{
          backgroundColor: modules?.challenges
            ? colors.buttonActive
            : "#444",
          padding: 18,
          borderRadius: 12,
          marginBottom: 12,
        }}
        disabled={!modules?.challenges}
      >
        <AppText
          style={{ color: "#fff", fontWeight: "bold", textAlign: "center" }}
        >
          Randomize a daily challenge
        </AppText>
      </TouchableOpacity>

      <TouchableOpacity
        onPress={modules?.challenges ? handleWeekly : undefined}
        style={{
          backgroundColor: modules?.challenges
            ? colors.buttonActive
            : "#444",
          padding: 18,
          borderRadius: 12,
          marginBottom: 12,
        }}
        disabled={!modules?.challenges}
      >
        <AppText
          style={{ color: "#fff", fontWeight: "bold", textAlign: "center" }}
        >
          Randomize a weekly challenge
        </AppText>
      </TouchableOpacity>

      <TouchableOpacity
        onPress={modules?.todos ? () => router.push("/random/todo") : undefined}
        style={{
          backgroundColor: modules?.todos
            ? colors.buttonActive
            : "#444",
          padding: 18,
          borderRadius: 12,
          marginBottom: 12,
        }}
        disabled={!modules?.todos}
      >
        <AppText
          style={{ color: "#fff", fontWeight: "bold", textAlign: "center" }}
        >
          Randomize a todo
        </AppText>
      </TouchableOpacity>
    </View>
  );
}


########## KONIEC PLIKU: frontend\app\(tabs)\RandomHomeScreen.tsx ##########



########## START PLIK: frontend\app\(tabs)\SettingsScreen.tsx ##########

import { View, Switch, StyleSheet, TouchableOpacity } from "react-native";
import AppText from "../../components/AppText";
import { useModuleSettingsStore } from "../stores/useModuleSettingsStore";
import { colors, spacing } from "../../constants/theme";
import { ScrollView } from "react-native-gesture-handler";
import { useEffect } from "react";
import { useGamificationStore } from "../stores/useGamificationStore";
import {
  BASE_XP,
  MODULE_MULTIPLIER,
  CHALLENGE_PERIOD_MULTIPLIER,
  GOAL_PERIOD_MULTIPLIER,
} from "../../constants/xpPreview";
import { calcXpPreview } from "../../utils/calcXpPreview";
import * as FileSystem from "expo-file-system/legacy";
import * as Sharing from "expo-sharing";
import * as DocumentPicker from "expo-document-picker";
import { api } from "../api/apiClient";


export default function SettingsScreen() {
const { raw, modules, dashboardTiles, toggleModule, toggleTile, pendingModuleToggles, fetchModules } =
  useModuleSettingsStore();

  useEffect(() => {
  fetchModules();
}, []);

  const capitalize = (s: string) =>
  s.charAt(0).toUpperCase() + s.slice(1);

  const { xpMultiplier, setXpMultiplier } = useGamificationStore();

const handleExport = async () => {
  try {
    const res = await api.get("/settings/export/");
    const data = res.data;

    const fileUri = FileSystem.documentDirectory + "backup.json";

    await FileSystem.writeAsStringAsync(
      fileUri,
      JSON.stringify(data)
    );

    await Sharing.shareAsync(fileUri);
  } catch (e) {
    console.log("Export error:", e);
  }
};

const handleImport = async () => {
  try {
    const result = await DocumentPicker.getDocumentAsync({
      type: "application/json",
    });

    if (result.canceled) return;

    const fileContent = await FileSystem.readAsStringAsync(
      result.assets[0].uri
    );

    await api.post("/settings/import/", JSON.parse(fileContent));

    alert("Import finished. Restart app.");
  } catch (e) {
    console.log("Import error:", e);
  }
};

  const XP_TABLE_CONFIG: XpTableRow[] = [
    { label: "Habits", module: "habits" },
    { label: "Todos", module: "todos" },

    {
      label: "Challenges (daily)",
      module: "challenges",
      periodMultiplier: CHALLENGE_PERIOD_MULTIPLIER.daily,
    },
    {
      label: "Challenges (weekly)",
      module: "challenges",
      periodMultiplier: CHALLENGE_PERIOD_MULTIPLIER.weekly,
    },

    {
      label: "Goals (weekly)",
      module: "goals",
      periodMultiplier: GOAL_PERIOD_MULTIPLIER.weekly,
    },
    {
      label: "Goals (monthly)",
      module: "goals",
      periodMultiplier: GOAL_PERIOD_MULTIPLIER.monthly,
    },
    {
      label: "Goals (yearly)",
      module: "goals",
      periodMultiplier: GOAL_PERIOD_MULTIPLIER.yearly,
    },
  ];

  type XpTableRow = {
    label: string;
    module: "habits" | "todos" | "challenges" | "goals";
    periodMultiplier?: number;
  };

  return (
    <ScrollView style={{ flex: 1, padding: spacing.l, backgroundColor: colors.background  }} contentContainerStyle={{
    paddingBottom: 30,
  }} >
      
      <AppText style={{ fontWeight: "700", marginBottom: 10 }}>Modules</AppText>
      {raw.map((m) => (
        <View key={m.id} style={styles.row}>
          <AppText>{capitalize(m.module)}</AppText>
          <Switch
            value={m.is_enabled}
            onValueChange={(v) => toggleModule(m.id, v)}
            trackColor={{ 
                false: colors.card, 
                true: colors.buttonActive 
              }}
            disabled={pendingModuleToggles.includes(m.id)}
            thumbColor={colors.light}
          />
        </View>
      ))}

      <AppText style={{ fontWeight: "700", marginVertical: 10 }}>Dashboard tiles</AppText>
      {dashboardTiles
        .filter(tile => !tile.module_dependency || modules?.[tile.module_dependency])
        .map((tile) => (
          <View key={tile.id} style={styles.row}>
            <AppText>{tile.name}</AppText>
            <Switch
              value={tile.is_enabled}
              onValueChange={(v) => toggleTile(tile.key, v)}
              trackColor={{ 
                false: colors.card,
                true: colors.buttonActive
              }}
              thumbColor={colors.light}

            />
          </View>
      ))}

        <AppText style={{ fontWeight: "700", marginVertical: 10 }}>XP multiplier</AppText>
        <View style={{ flexDirection: "row", gap: 10 }}>
        {[0.5, 1, 1.5, 2].map((v) => (
          <TouchableOpacity
            key={v}
            onPress={() => setXpMultiplier(v)}
            style={{
              paddingVertical: 8,
              paddingHorizontal: 14,
              borderRadius: 8,
              backgroundColor:
                xpMultiplier === v ? colors.buttonActive : colors.card,
            }}
          >
            <AppText style={{ color: colors.text }}>x{v}</AppText>
          </TouchableOpacity>
        ))}
      </View>

      <AppText style={{ fontWeight: "700", marginTop: spacing.l }}>
        XP breakdown
      </AppText>

      <View style={styles.table}>
        <View style={styles.headerRow}>
          <View style={styles.cellModule}>
            <AppText style={{ fontWeight: "600" }}>Module</AppText>
          </View>
          <View style={styles.cellXp}>
            <AppText style={{ fontWeight: "600" }}>Easy</AppText>
          </View>
          <View style={styles.cellXp}>
            <AppText style={{ fontWeight: "600" }}>Medium</AppText>
          </View>
          <View style={styles.cellXp}>
            <AppText style={{ fontWeight: "600" }}>Hard</AppText>
          </View>
        </View>

      {XP_TABLE_CONFIG.map((tableRow) => (
        <View key={tableRow.label} style={styles.tableRow}>
          <View style={styles.cellModule}>
            <AppText>{tableRow.label}</AppText>
          </View>

          {(["easy", "medium", "hard"] as const).map((diff) => (
            <View key={diff} style={styles.cellXp}>
              <AppText>
                {calcXpPreview({
                  baseXp: BASE_XP[diff],
                  moduleMultiplier: MODULE_MULTIPLIER[tableRow.module],
                  periodMultiplier: tableRow.periodMultiplier ?? 1,
                  xpMultiplier,
                })}
              </AppText>
            </View>
          ))}
        </View>
      ))}

      </View>

<AppText style={{ fontWeight: "700", marginTop: spacing.l }}>
  Backup
</AppText>

<View style={{ flexDirection: "row", gap: 12, marginTop: spacing.s }}>
  <TouchableOpacity
    onPress={handleExport}
    style={{
      flex: 1,
      paddingVertical: 10,
      borderRadius: 8,
      backgroundColor: colors.card,
      alignItems: "center",
    }}
  >
    <AppText>Export data</AppText>
  </TouchableOpacity>

  <TouchableOpacity
    onPress={handleImport}
    style={{
      flex: 1,
      paddingVertical: 10,
      borderRadius: 8,
      backgroundColor: colors.card,
      alignItems: "center",
    }}
  >
    <AppText>Import data</AppText>
  </TouchableOpacity>
</View>

    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    padding: spacing.l,
    backgroundColor: colors.background,
  },
  row: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: spacing.m,
  },
  table: {
    borderWidth: 1,
    borderColor: colors.card,
    borderRadius: 8,
    overflow: "hidden",
    marginTop: spacing.s,
  },

  headerRow: {
    flexDirection: "row",
    backgroundColor: colors.card,
    paddingVertical: 6,
    paddingHorizontal: 8,
  },

  tableRow: {
    flexDirection: "row",
    paddingVertical: 6,
    paddingHorizontal: 8,
    borderTopWidth: 1,
    borderTopColor: colors.card,
  },

  cellModule: { flex: 2 },
  cellXp: { flex: 1, alignItems: "flex-end" },

});


########## KONIEC PLIKU: frontend\app\(tabs)\SettingsScreen.tsx ##########



########## START PLIK: frontend\app\(tabs)\TodosScreen.tsx ##########

import React, { useEffect, useState, useCallback } from "react";
import {
  View,
  TouchableOpacity,
  ScrollView,
  FlatList,
  Alert,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
} from "react-native";
import AppText from "../../components/AppText";
import { colors, radius } from "../../constants/theme";
import { useTodoStore } from "../stores/useTodoStore";
import { useRouter } from "expo-router";
import TodoItem from "../../features/todos/TodoItem";
import BottomInputBar from "../../features/todos/BottomInputBar";
import CustomDifficultyPicker from "../../features/todos/customDifficultyPicker";
import EditTodoPopup from "../../features/todos/editTodoPopup";
import { useModuleSettingsStore } from "../stores/useModuleSettingsStore";
import { useGamificationStore } from "../stores/useGamificationStore";
import { useFocusEffect } from "@react-navigation/native";

export default function TodosScreen() {
  const router = useRouter();

  const {
    categories,
    tasks,
    loading,
    loadCategories,
    loadTasks,
    quickAddTask,
    completeTask,
    deleteTask,
    selectedCategoryId,
    setSelectedCategoryId,
  } = useTodoStore();

  
  const [quickText, setQuickText] = useState("");
  const [customDifficulty, setCustomDifficulty] = useState<number | null>(null);
  const [showDifficulty, setShowDifficulty] = useState(false);
  const [editingTodo, setEditingTodo] = useState<any | null>(null);
  const [showCompleted, setShowCompleted] = useState(false);

  const { modules } = useModuleSettingsStore();
  const gamificationOn = modules?.gamification;

  useFocusEffect(
    useCallback(() => {
      loadCategories();
    }, [])
  );

  useEffect(() => {
    if (!categories.length) {
      setSelectedCategoryId(null);
      return;
    }

    if (
      selectedCategoryId === null ||
      !categories.some((c) => c.id === selectedCategoryId)
    ) {
      setSelectedCategoryId(categories[0].id);
    }
  }, [categories]);

  useEffect(() => {
    if (selectedCategoryId !== null) {
      loadTasks(selectedCategoryId);
    }
  }, [selectedCategoryId]);

  const onQuickAdd = async () => {
    if (!quickText.trim() || !selectedCategoryId) return;

    try {
      await quickAddTask(
        selectedCategoryId,
        quickText.trim(),
        customDifficulty
      );
      setQuickText("");
      setCustomDifficulty(null);
    } catch {
      Alert.alert("Error", "Cannot add todo.");
    }
  };

  return (
    <View style={{ flex: 1, backgroundColor: colors.background }}>

      {showDifficulty && (
        <CustomDifficultyPicker
          onSelect={(d: any) => {
            setCustomDifficulty(d.id);
            setShowDifficulty(false);
          }}
          onClose={() => setShowDifficulty(false)}
        />
      )}


      {editingTodo && (
        <EditTodoPopup
          item={editingTodo}
          onClose={() => setEditingTodo(null)}
          onSaved={async () => {
            setEditingTodo(null);
            await loadTasks(selectedCategoryId!);
          }}
          onDelete={async (taskId: number) => {
            try {
              await deleteTask(taskId);
            } catch {
              Alert.alert("Error", "Failed to delete task");
            }
          }}
        />
      )}

      <View style={{ flexDirection: "row", marginBottom: 12, padding: 12 }}>
        <ScrollView horizontal showsHorizontalScrollIndicator={false}>
          {categories.map((cat) => (
            <TouchableOpacity
              key={cat.id}
              onPress={() => setSelectedCategoryId(cat.id)}
              onLongPress={() => router.push(`/editCategory/${cat.id}`)}
              style={{
                padding: 12,
                marginRight: 8,
                borderRadius: radius.md,
                backgroundColor: cat.color || colors.card,
                minWidth: 80,
                alignItems: "center",
                borderWidth: 2,
                borderColor: selectedCategoryId === cat.id
                  ? colors.light
                  : "transparent",
              }}
            >
              <AppText>{cat.name}</AppText>
              {gamificationOn && (
                <AppText style={{ fontSize: 12 }}>
                  {cat.difficulty?.name}
                </AppText>
              )}
            </TouchableOpacity>
          ))}

          <TouchableOpacity
            onPress={() => router.push("/addCategory")}
            style={{
              padding: 12,
              borderRadius: radius.md,
              backgroundColor: colors.buttonActive,
              justifyContent: "center",
              alignItems: "center",
            }}
          >
            <AppText style={{ color: "#fff", fontSize: 18 }}>＋</AppText>
          </TouchableOpacity>
        </ScrollView>
      </View>

      <TouchableOpacity
        onPress={() => setShowCompleted((prev) => !prev)}
        style={{
          padding: 8,
          marginBottom: 12,
          backgroundColor: colors.buttonActive,
          alignItems: "center",
        }}
      >
        <AppText style={{ color: "#fff" }}>
          {showCompleted ? "Show todo" : "Show completed"}
        </AppText>
      </TouchableOpacity>

      <KeyboardAvoidingView
        style={{ flex: 1 }}
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        keyboardVerticalOffset={Platform.OS === "ios" ? 0 : 80}
      >
        {loading.tasks ? (
          <View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}>
            <ActivityIndicator color={colors.buttonActive} />
          </View>
        ) : tasks.filter((t) =>
            showCompleted ? t.is_completed : !t.is_completed
          ).length === 0 ? (
          <View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}>
            <AppText style={{ color: "#777" }}>
              {showCompleted
                ? "no completed tasks yet"
                : "no tasks in this category yet"}
            </AppText>
          </View>
        ) : (
          <FlatList
            data={tasks.filter((t) =>
              showCompleted ? t.is_completed : !t.is_completed
            )}
            keyExtractor={(item) => item.id.toString()}
            renderItem={({ item }) => (
              <TodoItem
                item={item}
                onComplete={async (taskId) => {
                  const res = await completeTask(taskId);
                  if (res && gamificationOn && res.xp_gained > 0) {
                    useGamificationStore
                      .getState()
                      .applyXpResult(res);
                  }
                }}
                onDelete={async (taskId) => {
                  try {
                    await deleteTask(taskId);
                  } catch {
                    Alert.alert("Error", "Cannot delete task");
                  }
                }}
                onLongPress={() => setEditingTodo(item)}
              />
            )}
            contentContainerStyle={{ paddingBottom: 120 }}
          />
        )}

        <BottomInputBar
          quickText={quickText}
          setQuickText={setQuickText}
          onQuickAdd={onQuickAdd}
          onOpenDifficulty={() => setShowDifficulty(true)}
        />
      </KeyboardAvoidingView>
    </View>
  );
}


########## KONIEC PLIKU: frontend\app\(tabs)\TodosScreen.tsx ##########



########## START PLIK: frontend\app\(tabs)\_layout.tsx ##########

import { Tabs } from "expo-router";
import { Ionicons } from "@expo/vector-icons";
import { colors, fonts } from "../../constants/theme";
import { ModuleKey, useModuleSettingsStore } from "../stores/useModuleSettingsStore";
import { View, ActivityIndicator } from "react-native";
import { useEffect } from "react";

export default function TabsLayout() {
  const { modules, fetchModules } = useModuleSettingsStore();

  const TAB_MODULE_MAP: Record<string, ModuleKey | null> = {
  index: null,
  HabitsScreen: "habits",
  TodosScreen: "todos",
  ChallengesListScreen: "challenges",
  GoalsScreen: "goals",
  RandomHomeScreen: "random",
  GamificationScreen: "gamification",
  SettingsScreen: null,
  };


  const isTabEnabled = (routeName: string) => {
    const module = TAB_MODULE_MAP[routeName];
    if (!module) return true;
    return modules?.[module];
  };

  const TAB_CONFIG: Record<
    string,
    {
      label: string;
      icon: keyof typeof Ionicons.glyphMap;
      iconOutline: keyof typeof Ionicons.glyphMap;
    }
  > = {
    index: {
      label: "Home",
      icon: "home",
      iconOutline: "home-outline",
    },
    HabitsScreen: {
      label: "Habits",
      icon: "repeat",
      iconOutline: "repeat-outline",
    },
    TodosScreen: {
      label: "Todos",
      icon: "checkbox",
      iconOutline: "checkbox-outline",
    },
    ChallengesListScreen: {
      label: "Challenges",
      icon: "flame",
      iconOutline: "flame-outline",
    },
    GoalsScreen: {
      label: "Goals",
      icon: "flag",
      iconOutline: "flag-outline",
    },
    RandomHomeScreen: {
      label: "Random",
      icon: "shuffle",
      iconOutline: "shuffle-outline",
    },
    GamificationScreen: {
      label: "Level",
      icon: "game-controller",
      iconOutline: "game-controller-outline",
    },
    SettingsScreen: {
      label: "Settings",
      icon: "settings",
      iconOutline: "settings-outline",
    },
  };

  useEffect(() => {
    fetchModules();
  }, []);

  if (!modules) {
    return (
      <View
        style={{
          flex: 1,
          justifyContent: "center",
          alignItems: "center",
          backgroundColor: colors.background,
        }}
      >
        <ActivityIndicator size="large" color={colors.buttonActive} />
      </View>
    );
  }

  return (
    
      <Tabs
        initialRouteName="index"
        screenOptions={( { route })  => {
          const config = TAB_CONFIG[route.name];

          return {
            headerShown: true,
            headerTitle: config?.label ?? "",
            headerStyle: {
              backgroundColor: colors.background,
            },
            headerTitleStyle: {
              color: colors.text,
              fontSize: 20,
              fontFamily: fonts.nunitoRegular,
            },
            headerShadowVisible: false,

            tabBarShowLabel: false,
            tabBarStyle: {
              backgroundColor: "#15151aff",
              borderTopColor: "transparent",
              height: 68,
            },

            tabBarIcon: ({ focused }) => {
              if (!config) return null;

              return (
                <View
                  style={{
                    alignItems: "center",
                    justifyContent: "center",
                    minWidth: 80,
                    height: 40,
                    marginTop: 25,
                  }}
                >
                  <Ionicons
                    name={focused ? config.icon : config.iconOutline}
                    size={18}
                    color={focused ? colors.buttonActive : "#7a7891"}
                  />

                </View>
              );
            },
          };
        }}
      >
    <Tabs.Screen
      name="index"
      options={{
        href: isTabEnabled("index") ? undefined : null,
      }}
    />

    <Tabs.Screen
      name="HabitsScreen"
      options={{
        href: isTabEnabled("HabitsScreen") ? undefined : null,
      }}
    />

    <Tabs.Screen
      name="TodosScreen"
      options={{
        href: isTabEnabled("TodosScreen") ? undefined : null,
      }}
    />

    <Tabs.Screen
      name="ChallengesListScreen"
      options={{
        href: isTabEnabled("ChallengesListScreen") ? undefined : null,
      }}
    />

    <Tabs.Screen
      name="GoalsScreen"
      options={{
        href: isTabEnabled("GoalsScreen") ? undefined : null,
      }}
    />

    <Tabs.Screen
      name="RandomHomeScreen"
      options={{
        href: isTabEnabled("RandomHomeScreen") ? undefined : null,
      }}
    />

    <Tabs.Screen
      name="GamificationScreen"
      options={{
        href: isTabEnabled("GamificationScreen") ? undefined : null,
      }}
    />

    <Tabs.Screen
      name="SettingsScreen"
      options={{
        href: isTabEnabled("SettingsScreen") ? undefined : null,
      }}
    />
  </Tabs>
  );
}


########## KONIEC PLIKU: frontend\app\(tabs)\_layout.tsx ##########



########## START PLIK: frontend\app\(tabs)\index.tsx ##########

import React, { useState, useCallback } from "react";
import {
  View,
  ScrollView,
  ActivityIndicator,
} from "react-native";
import { colors, spacing } from "../../constants/theme";
import { useRouter } from "expo-router";
import { useFocusEffect } from "@react-navigation/native";

import { DashboardTileKey, useModuleSettingsStore } from "../stores/useModuleSettingsStore";
import { useGamificationStore } from "../stores/useGamificationStore";
import { useChallengeStore } from "../stores/useChallengeStore";
import { RandomHabitSummary, useHabitStore } from "../stores/useHabitStore";
import { useGoalStore } from "../stores/useGoalStore";
import { useTodoStore } from "../stores/useTodoStore";
import { useNotesStore } from "../stores/useNotesStore";
import { LevelTile } from "../../components/dashboard/LevelTile";
import { BiggestStreakTile } from "../../components/dashboard/BiggestStreak";
import { RandomGoalTile } from "../../components/dashboard/RandomGoalTile";
import { DailyChallengeTile } from "../../components/dashboard/DailyChallengeTile";
import { WeeklyChallengeTile } from "../../components/dashboard/WeeklyChallengeTile";
import { RandomTodoTile } from "../../components/dashboard/RandomTodoTile";
import { RandomNoteTile } from "../../components/dashboard/RandomNoteTile";
import { RandomHabitTile } from "../../components/dashboard/RandomHabitTile";
import EditTodoPopup from "../../features/todos/editTodoPopup";

export default function DashboardScreen() {
  const router = useRouter();

  const { dashboardTiles, modules, fetchModules } = useModuleSettingsStore();

  const {
    totalXp,
    currentLevel: level,
    fetchUser,
  } = useGamificationStore();

  const {
    fetchActive,
    activeDaily,
    activeWeekly,
  } = useChallengeStore();

  const {
    fetchStreaks,
    biggestStreak,
    loadMonth,
  } = useHabitStore();

  const { pickRandomGoal } = useGoalStore();
  const { fetchRandomTask } = useTodoStore();
  const { randomNote, fetchRandomNote } = useNotesStore();
  const [loading, setLoading] = useState(true);
  const [goalWeek, setGoalWeek] = useState<any | null>(null);
  const [goalMonth, setGoalMonth] = useState<any | null>(null);
  const [goalYear, setGoalYear] = useState<any | null>(null);
  const [randomTodo, setRandomTodo] = useState<any | null>(null);
  const [randomHabit, setRandomHabit] = useState<RandomHabitSummary | null>(null);
  const [editingTodo, setEditingTodo] = useState<any | null>(null);

  const GOAL_CONFIG: {
    key: DashboardTileKey;
    label: string;
    goal: any | null;
    period: "weekly" | "monthly" | "yearly";
  }[] = [
    {
      key: "goal_week",
      label: "Random week goal",
      goal: goalWeek,
      period: "weekly",
    },
    {
      key: "goal_month",
      label: "Random month goal",
      goal: goalMonth,
      period: "monthly",
    },
    {
      key: "goal_year",
      label: "Random year goal",
      goal: goalYear,
      period: "yearly",
    },
  ];

  const fetchAll = useCallback(async () => {
    setLoading(true);
    try {
      await Promise.all([
        fetchModules?.(),
        fetchUser?.(),
        fetchActive?.(),
        fetchStreaks?.(),
        fetchRandomNote?.(),
        loadMonth?.(),
      ]);

      const [gw, gm, gy] = await Promise.all([
        pickRandomGoal?.("weekly"),
        pickRandomGoal?.("monthly"),
        pickRandomGoal?.("yearly"),
      ]);

      setGoalWeek(gw ?? null);
      setGoalMonth(gm ?? null);
      setGoalYear(gy ?? null);

      const todo = await fetchRandomTask?.();
      setRandomTodo(todo ?? null);

      const rh = await useHabitStore
        .getState()
        .pickRandomHabitSummary();

      setRandomHabit(rh ?? null);


    } catch (e) {
      console.error("Dashboard fetch error:", e);
    } finally {
      setLoading(false);
    }
  }, []);

  useFocusEffect(
    useCallback(() => {
      fetchAll();
    }, [fetchAll])
  );


  const canRenderTile = (key: DashboardTileKey) => {
    const tile = dashboardTiles?.find(
      (t: any) => t.key === key || t.id === key
    );
    if (!tile || !tile.is_enabled) return false;

    if (tile.module_dependency) {
      return modules?.[tile.module_dependency] === true;
    }

    return true;
  };

  if (loading) {
    return (
      <View
        style={{
          flex: 1,
          justifyContent: "center",
          alignItems: "center",
          backgroundColor: colors.background,
        }}
      >
        <ActivityIndicator size="large" color={colors.buttonActive} />
      </View>
    );
  }

  return (
    <ScrollView style={{ flex: 1, padding: spacing.m, backgroundColor: colors.background}} contentContainerStyle={{
      paddingBottom: 30,
    }}>

      {editingTodo && (
        <EditTodoPopup
          item={editingTodo}
          onClose={async () => {
            setEditingTodo(null);

            const refreshed = await fetchRandomTask?.();
            setRandomTodo(refreshed ?? null);
          }}
        />
      )}


      {canRenderTile("level_gamification") && (
        <LevelTile
          level={level}
          totalXp={totalXp}
          onPress={() => router.push("/GamificationScreen")}
        />
      )}


      {canRenderTile("biggest_streak") && (
        <BiggestStreakTile
          streak={biggestStreak}
          onPress={() => router.push("/HabitsScreen")}
          onEditHabit={(id) =>
            router.push({
              pathname: "/editHabit/[id]",
              params: { id: String(id) },
            })
          }
        />
      )}

      {GOAL_CONFIG.map(({ key, label, goal, period }) =>
          canRenderTile(key) ? (
            <RandomGoalTile
              key={key}
              label={label}
              goal={goal}
              onRefresh={async () => {
                const next = await pickRandomGoal?.(period);
                if (!next) return;

                if (period === "weekly") setGoalWeek(next);
                if (period === "monthly") setGoalMonth(next);
                if (period === "yearly") setGoalYear(next);
              }}
              onEditGoal={(id) =>
                router.push({
                  pathname: "/editGoal/[id]",
                  params: { id: String(id) },
                })
              }
            />
          ) : null
        )}

        {canRenderTile("daily_challenge") && (
          <DailyChallengeTile
            activeDaily={activeDaily}
            onGoToActive={() => router.push("/random/daily/active")}
            onRandomize={() => router.push("/random/daily")}
            onEdit={(id) =>
              router.push({
                pathname: "/editChallenge/[id]",
                params: { id: String(id) },
              })
            }
          />
        )}

        {canRenderTile("weekly_challenge") && (
          <WeeklyChallengeTile
            activeWeekly={activeWeekly}
            onGoToActive={() => router.push("/random/weekly/active")}
            onRandomize={() => router.push("/random/weekly")}
            onEdit={(id) =>
              router.push({
                pathname: "/editChallenge/[id]",
                params: { id: String(id) },
              })
            }
          />
        )}

        {canRenderTile("random_todo") && (
          <RandomTodoTile
            todo={randomTodo}
            onRefresh={async () => {
              const todo = await fetchRandomTask?.();
              setRandomTodo(todo ?? null);
            }}
            onEdit={(todo) => setEditingTodo(todo)}
          />
        )}


        {canRenderTile("random_note") && (
          <RandomNoteTile
            note={randomNote}
            onRefresh={fetchRandomNote}
            onEdit={(id) =>
              router.push({
                pathname: "/editNote/[id]",
                params: { id: String(id) },
              })
            }
            onAdd={() => router.push("/addNote")}
          />
        )}

        {canRenderTile("random_habit") && (
          <RandomHabitTile
            habit={randomHabit}
            onRefresh={async () => {
              const rh = await useHabitStore
                .getState()
                .pickRandomHabitSummary();
              setRandomHabit(rh ?? null);
            }}
            onEdit={(id) =>
              router.push({
                pathname: "/editHabit/[id]",
                params: { id: String(id) },
              })
            }
          />
        )}

    </ScrollView>
  );
}

########## KONIEC PLIKU: frontend\app\(tabs)\index.tsx ##########



########## START PLIK: frontend\app\_layout.tsx ##########

import { Stack } from "expo-router";
import { useFonts } from "expo-font";
import {
  Inter_400Regular, Inter_500Medium, Inter_600SemiBold, Inter_700Bold
} from "@expo-google-fonts/inter";
import { Poppins_400Regular, Poppins_600SemiBold } from "@expo-google-fonts/poppins";
import { Nunito_400Regular, Nunito_700Bold } from "@expo-google-fonts/nunito";
import { Manrope_400Regular, Manrope_600SemiBold } from "@expo-google-fonts/manrope";
import { ActivityIndicator, View } from "react-native";
import { colors } from "../constants/theme";
import XPPopup from "../components/XPPopup";
import { defaultHeaderOptions } from "../components/NavigationHeader";
import { GestureHandlerRootView } from "react-native-gesture-handler";
import { ThemeProvider, DarkTheme } from "@react-navigation/native";


export default function RootLayout() {
  const [loaded] = useFonts({
    Inter_400Regular, Inter_500Medium, Inter_600SemiBold, Inter_700Bold,
    Poppins_400Regular, Poppins_600SemiBold,
    Nunito_400Regular, Nunito_700Bold,
    Manrope_400Regular, Manrope_600SemiBold,
  });

  const AppTheme = {
    ...DarkTheme,
    colors: {
      ...DarkTheme.colors,
      background: colors.background,
      card: colors.background,
    },
  };

  if (!loaded) {
    return (
      <View style={{ flex: 1, backgroundColor: colors.background, alignItems: "center", justifyContent: "center" }}>
        <ActivityIndicator size="large" color={colors.buttonActive} />
      </View>
    );
  }

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
     <ThemeProvider value={AppTheme}>
      <Stack
          screenOptions={{
            contentStyle: { backgroundColor: colors.background },
          }}
        >
        <Stack.Screen name="(tabs)" options={{ headerShown: false }} />

        <Stack.Screen name="addHabit" options={defaultHeaderOptions} />
        <Stack.Screen name="editHabit/[id]" options={defaultHeaderOptions}  />

        <Stack.Screen name="addGoal" options={defaultHeaderOptions} />
        <Stack.Screen name="editGoal/[id]" options={defaultHeaderOptions} />

        <Stack.Screen name="addChallenge" options={defaultHeaderOptions} />
        <Stack.Screen name="editChallenge/[id]" options={defaultHeaderOptions} />

        <Stack.Screen name="addNote" options={defaultHeaderOptions} />
        <Stack.Screen name="editNote/[id]" options={defaultHeaderOptions} />

        <Stack.Screen name="addTag" options={defaultHeaderOptions} />
        <Stack.Screen name="editTag/[id]" options={defaultHeaderOptions} />

        <Stack.Screen name="addCategory" options={defaultHeaderOptions} />
        <Stack.Screen name="editCategory/[id]" options={defaultHeaderOptions} />

        <Stack.Screen name="random" options={{ headerShown: false }} />

      </Stack>

      <XPPopup />
    </ThemeProvider>
    </GestureHandlerRootView>
  );
}


########## KONIEC PLIKU: frontend\app\_layout.tsx ##########



########## START PLIK: frontend\app\addCategory.tsx ##########

import { useLayoutEffect } from "react";
import { useNavigation } from "expo-router";
import CategoryFormScreen from "../features/todos/CategoryFormScreen";

export default function AddCategory() {
  const navigation = useNavigation();

  useLayoutEffect(() => {
    navigation.setOptions({
      headerTitle: "Add Category",
    });
  }, []);

  return <CategoryFormScreen />;
}

########## KONIEC PLIKU: frontend\app\addCategory.tsx ##########



########## START PLIK: frontend\app\addChallenge.tsx ##########

import { useEffect, useLayoutEffect } from "react";
import { useLocalSearchParams, useNavigation } from "expo-router";
import ChallengeFormScreen from "../features/challenges/ChallengeFormScreen";
import { useChallengeStore } from "./stores/useChallengeStore";


export default function AddChallenge() {
  const navigation = useNavigation();
  const { type } = useLocalSearchParams<{ type?: "daily" | "weekly" }>();
  const { setSelectedType } = useChallengeStore();

  useLayoutEffect(() => {
    navigation.setOptions({
      headerTitle: "Add Challenge",
    });
  }, []);

  useEffect(() => {
    if (type) {
      setSelectedType(type);
    }
  }, [type]);


  return <ChallengeFormScreen />;
}

########## KONIEC PLIKU: frontend\app\addChallenge.tsx ##########



########## START PLIK: frontend\app\addGoal.tsx ##########

import { useLayoutEffect } from "react";
import { useNavigation } from "expo-router";
import GoalFormScreen from "../features/goals/GoalFormScreen";

export default function AddGoal() {
  const navigation = useNavigation();

  useLayoutEffect(() => {
    navigation.setOptions({
      headerTitle: "Add Goal",
    });
  }, []);

  return <GoalFormScreen />;
}

########## KONIEC PLIKU: frontend\app\addGoal.tsx ##########



########## START PLIK: frontend\app\addHabit.tsx ##########

import { useLayoutEffect } from "react";
import { useNavigation } from "expo-router";
import HabitFormScreen from "../features/habits/HabitFormScreen";

export default function AddHabit() {
  const navigation = useNavigation();

  useLayoutEffect(() => {
    navigation.setOptions({
      headerTitle: "Add Habit",
    });
  }, []);

  return <HabitFormScreen />;
}


########## KONIEC PLIKU: frontend\app\addHabit.tsx ##########



########## START PLIK: frontend\app\addMood.tsx ##########

import { useLayoutEffect } from "react";
import { useNavigation, useLocalSearchParams } from "expo-router";
import MoodFormScreen from "../features/mood/MoodFormScreen";

export default function AddMood() {
  const navigation = useNavigation();
  const { date } = useLocalSearchParams();

  useLayoutEffect(() => {
    navigation.setOptions({
      headerTitle: "Add Mood",
    });
  }, []);

  return <MoodFormScreen initialDate={date as string} />;
}

########## KONIEC PLIKU: frontend\app\addMood.tsx ##########



########## START PLIK: frontend\app\addNote.tsx ##########

import { useLayoutEffect } from "react";
import { useNavigation } from "expo-router";
import NoteFormScreen from "../features/notes/NoteFormScreen";

export default function AddNote() {
  const navigation = useNavigation();

  useLayoutEffect(() => {
    navigation.setOptions({
      headerTitle: "Add Note",
    });
  }, []);

  return <NoteFormScreen />;
}


########## KONIEC PLIKU: frontend\app\addNote.tsx ##########



########## START PLIK: frontend\app\addTag.tsx ##########

import { useLayoutEffect } from "react";
import { useNavigation } from "expo-router";
import TagsFormScreen from "../features/challenges/TagsFormScreen";

export default function AddTag() {
  const navigation = useNavigation();

  useLayoutEffect(() => {
    navigation.setOptions({
      headerTitle: "Add Tag",
    });
  }, []);

  return <TagsFormScreen/>;
}

########## KONIEC PLIKU: frontend\app\addTag.tsx ##########



########## START PLIK: frontend\app\api\apiClient.ts ##########

import axios from "axios";

export const api = axios.create({
  //baseURL: "http://127.0.0.1:8000/api",
  baseURL: "http://10.176.243.57:8000/api",
  
});


########## KONIEC PLIKU: frontend\app\api\apiClient.ts ##########



########## START PLIK: frontend\app\editCategory\[id].tsx ##########

import { useLayoutEffect } from "react";
import { useNavigation, useLocalSearchParams } from "expo-router";
import CategoryFormScreen from "../../features/todos/CategoryFormScreen";

export default function EditCategory() {
  const navigation = useNavigation();
  const { id } = useLocalSearchParams();

  useLayoutEffect(() => {
    navigation.setOptions({ headerTitle: "Edit Category" });
  }, [id]);

  return <CategoryFormScreen editingId={Number(id)} />;
}

########## KONIEC PLIKU: frontend\app\editCategory\[id].tsx ##########



########## START PLIK: frontend\app\editChallenge\[id].tsx ##########

import { useLayoutEffect } from "react";
import { useNavigation, useLocalSearchParams } from "expo-router";
import ChallengeFormScreen from "../../features/challenges/ChallengeFormScreen";

export default function EditChallenge() {
  const navigation = useNavigation();
  const { id } = useLocalSearchParams();

  useLayoutEffect(() => {
    navigation.setOptions({ headerTitle: "Edit Challenge" });
  }, [id]);

  return <ChallengeFormScreen editingId={Number(id)} />;
}

########## KONIEC PLIKU: frontend\app\editChallenge\[id].tsx ##########



########## START PLIK: frontend\app\editGoal\[id].tsx ##########

import { useLayoutEffect } from "react";
import { useNavigation, useLocalSearchParams } from "expo-router";
import GoalFormScreen from "../../features/goals/GoalFormScreen";

export default function EditGoal() {
  const navigation = useNavigation();
  const { id } = useLocalSearchParams();

  useLayoutEffect(() => {
    navigation.setOptions({ headerTitle: "Edit Goal" });
  }, [id]);

  return <GoalFormScreen editingId={Number(id)} />;
}


########## KONIEC PLIKU: frontend\app\editGoal\[id].tsx ##########



########## START PLIK: frontend\app\editHabit\[id].tsx ##########

import { useLayoutEffect } from "react";
import { useNavigation, useLocalSearchParams } from "expo-router";
import HabitFormScreen from "../../features/habits/HabitFormScreen";

export default function EditHabit() {
  const navigation = useNavigation();
  const { id } = useLocalSearchParams();

  useLayoutEffect(() => {
    navigation.setOptions({ headerTitle: "Edit Habit" });
  }, [id]);

  return <HabitFormScreen editingId={Number(id)} />;
}


########## KONIEC PLIKU: frontend\app\editHabit\[id].tsx ##########



########## START PLIK: frontend\app\editMood\[id].tsx ##########

import { useLayoutEffect } from "react";
import { useNavigation, useLocalSearchParams } from "expo-router";
import MoodFormScreen from "../../features/mood/MoodFormScreen";

export default function EditMood() {
  const navigation = useNavigation();
  const { id } = useLocalSearchParams();

  useLayoutEffect(() => {
    navigation.setOptions({
      headerTitle: "Edit Mood",
    });
  }, [id]);

  return <MoodFormScreen editingId={Number(id)} />;
}

########## KONIEC PLIKU: frontend\app\editMood\[id].tsx ##########



########## START PLIK: frontend\app\editNote\[id].tsx ##########

import { useLayoutEffect } from "react";
import { useNavigation, useLocalSearchParams } from "expo-router";
import NoteFormScreen from "../../features/notes/NoteFormScreen";

export default function EditNote() {
  const navigation = useNavigation();
  const { id } = useLocalSearchParams();

  useLayoutEffect(() => {
    navigation.setOptions({ headerTitle: "Edit Note" });
  }, [id]);

  return <NoteFormScreen editingId={Number(id)} />;
}


########## KONIEC PLIKU: frontend\app\editNote\[id].tsx ##########



########## START PLIK: frontend\app\editTag\[id].tsx ##########

import { useLayoutEffect } from "react";
import { useNavigation, useLocalSearchParams } from "expo-router";
import TagsFormScreen from "../../features/challenges/TagsFormScreen";

export default function EditTag() {
  const navigation = useNavigation();
  const { id } = useLocalSearchParams();

  useLayoutEffect(() => {
    navigation.setOptions({ headerTitle: "Edit Tag" });
  }, [id]);

  return <TagsFormScreen editingId={Number(id)} />;
}


########## KONIEC PLIKU: frontend\app\editTag\[id].tsx ##########



########## START PLIK: frontend\app\random\_layout.tsx ##########

import { Stack } from "expo-router";

export default function RandomLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
      }}
    />
  );
}


########## KONIEC PLIKU: frontend\app\random\_layout.tsx ##########



########## START PLIK: frontend\app\random\daily\active.tsx ##########

import React, { useEffect, useState } from "react";
import { View, TouchableOpacity, Alert, ActivityIndicator } from "react-native";
import AppText from "../../../components/AppText";
import { useChallengeStore } from "../../stores/useChallengeStore";
import { colors } from "../../../constants/theme";
import { useRouter } from "expo-router";
import { useModuleSettingsStore } from "../../stores/useModuleSettingsStore";
import { useGamificationStore } from "../../stores/useGamificationStore";

export default function DailyActiveScreen() {
  const router = useRouter();
  const { fetchActive, activeDaily, discardUserChallenge, completeUserChallenge } = useChallengeStore();
  const [loading, setLoading] = useState(true);

  const { modules } = useModuleSettingsStore();
  const gamificationOn = modules?.gamification;

  useEffect(() => {
    const load = async () => {
      await fetchActive();
      setLoading(false);
    };
    load();
  }, []);

  useEffect(() => {
    if (!loading && !activeDaily) {
      router.replace("/random/daily");
    }
  }, [loading, activeDaily]);

  const tryAnother = async () => {
    try {
      await discardUserChallenge(activeDaily!.id);
      router.replace("/random/daily");
    } catch {
      Alert.alert("Error", "Could not discard the challenge");
    }
  };

  const onComplete = async () => {
    if (!activeDaily) return;
    const res = await completeUserChallenge(activeDaily.id);
    if (!res) return Alert.alert("Error", "Cannot complete the challenge");

    if (gamificationOn) {
      useGamificationStore.getState().applyXpResult(res);
    }

    router.replace("/(tabs)/RandomHomeScreen");
  };

  if (loading) {
  return <ActivityIndicator />
  }

  if (!activeDaily) {
    return null;
  }

  const challenge = activeDaily.challenge;

  return (
    <View style={{ flex: 1, padding: 24, backgroundColor: colors.background, justifyContent: "center" }}>
      <AppText style={{ fontWeight: "bold", fontSize: 14, marginBottom: 12, color: colors.light, fontStyle: "italic" }}>
        You have an active daily challenge!
      </AppText>
      
      <AppText style={{ fontSize: 20, fontWeight: "700", marginBottom: 6, lineHeight: 24, paddingBottom: 2 }}>
        {challenge?.title}
      </AppText>
      
      <AppText style={{ marginBottom: 18, marginTop: 5 }}>
        {challenge?.description}
      </AppText>

      <TouchableOpacity onPress={tryAnother} style={{ backgroundColor: colors.card, padding: 12, borderRadius: 10, marginBottom: 10 }}>
        <AppText style={{ textAlign: "center"}}>
          Try another
          {gamificationOn ? " (no XP)" : ""}
        </AppText>
      </TouchableOpacity>

      <TouchableOpacity onPress={onComplete} style={{ backgroundColor: colors.buttonActive, padding: 12, borderRadius: 10, marginBottom: 10 }}>
        <AppText style={{ textAlign: "center", color: "#fff", fontWeight: "bold" }}>Completed</AppText>
      </TouchableOpacity>

      <TouchableOpacity onPress={() => router.replace("/(tabs)/RandomHomeScreen")} style={{ backgroundColor: colors.card, padding: 12, borderRadius: 10 }}>
        <AppText style={{ textAlign: "center", fontWeight: "bold" }}>Go back</AppText>
      </TouchableOpacity>
    </View>
  );
}


########## KONIEC PLIKU: frontend\app\random\daily\active.tsx ##########



########## START PLIK: frontend\app\random\daily\index.tsx ##########

import React, { useEffect, useState } from "react";
import { View, TouchableOpacity, ScrollView, Alert } from "react-native";
import AppText from "../../../components/AppText";
import { useChallengeStore } from "../../stores/useChallengeStore";
import { useRouter } from "expo-router";
import { colors } from "../../../constants/theme";
import RandomSpin from "../spin";

export default function DailyPickScreen() {
  const router = useRouter();
  const { loadTags, tags, fetchRandomChallenge, loadDifficulties, difficulties } = useChallengeStore();
  const [selectedTags, setSelectedTags] = useState<number[]>([]);
  const [spinning, setSpinning] = useState(false);
  const [spinItems, setSpinItems] = useState<string[]>([]);
  const [selectedDifficulty, setSelectedDifficulty] = useState<number | null>(null);
  const [hasAvailableChallenge, setHasAvailableChallenge] = useState<boolean | null>(null);

  useEffect(() => {
    loadTags();
  if (typeof loadDifficulties === "function") loadDifficulties();
  }, []);

  useEffect(() => {
    const check = async () => {
      if (selectedTags.length === 0 && selectedDifficulty === null) {
        setHasAvailableChallenge(true);
        return;
      }

      const test = await fetchRandomChallenge(
        "daily",
        selectedTags,
        selectedDifficulty
      );

      setHasAvailableChallenge(!!test);
    };

    check();
  }, [selectedTags, selectedDifficulty]);



  const toggleTag = (id:number) => setSelectedTags(prev => prev.includes(id) ? prev.filter(x=>x!==id) : [...prev, id]);

  const onLosuj = async () => {
    if (!tags.length) {
      Alert.alert("No tags.");
      return;
    }

    let picked = null;

    const hasTags = selectedTags.length > 0;
    const hasDifficulty = selectedDifficulty !== null;

    if (hasTags) {
      picked = await fetchRandomChallenge(
        "daily",
        selectedTags,
        selectedDifficulty
      );

      if (!picked) {
        picked = await fetchRandomChallenge("daily", selectedTags, null);
      }

    } else if (hasDifficulty) {
      picked = await fetchRandomChallenge("daily", [], selectedDifficulty);
    }

    if (!picked) {
      Alert.alert(
        "No matching challenge",
        "No challenge matches the selected filters."
      );
      return;
    }

    setSpinItems(["...", "Randomizing", "Searching", "Wait", "OK"]);
    setSpinning(true);

    setTimeout(() => {
      setSpinning(false);
      router.push({
        pathname: "/random/result",
        params: {
          item: JSON.stringify(picked),
          source: "challenge",
        },
      });
    }, 600);
  };

  if (spinning) return <RandomSpin items={spinItems.length ? spinItems : ["..."]} onFinish={() => {}} />;

  const randomDisabled = hasAvailableChallenge === false;

  return (
    <View style={{ flex:1, backgroundColor: colors.background }}>
      <ScrollView 
        contentContainerStyle={{ 
          flexGrow: 1, 
          justifyContent: "center",
          alignItems: "center",
          padding: 16
        }}
        showsVerticalScrollIndicator={false}
      >
        <TouchableOpacity
          disabled={randomDisabled}
          onPress={onLosuj}
          style={{
            backgroundColor: randomDisabled
              ? colors.card
              : colors.buttonActive,
            padding: 16,
            borderRadius: 10,
            marginBottom: 12,
            width: "80%",
            alignItems: "center",
            opacity: randomDisabled ? 0.6 : 1,
          }}
        >

          <AppText style={{ color:"#fff", fontWeight:"bold" }}>Randomize!</AppText>
        </TouchableOpacity>

        {hasAvailableChallenge === false && (
          <AppText style={{ marginBottom: 12, color: "#999" }}>
            No challenges match the selected filters
          </AppText>
        )}

        <AppText style={{ marginBottom:8 }}>Filter by tags:</AppText>

        <View style={{ flexDirection:"row", flexWrap:"wrap", justifyContent:"center", alignItems:"center" }}>
          {tags.map(t => (
            <TouchableOpacity 
              key={t.id} 
              onPress={() => toggleTag(t.id)} 
              style={{ 
                padding:8, 
                margin:6, 
                borderRadius:8, 
                backgroundColor: selectedTags.includes(t.id) ? colors.buttonActive : colors.card 
              }}
            >
              <AppText>{t.name}</AppText>
            </TouchableOpacity>
          ))}
        </View>

        <AppText style={{ marginBottom:8 }}>Filter by difficulty:</AppText>
          <View style={{ flexDirection:"row", flexWrap:"wrap", justifyContent:"center", alignItems:"center", marginBottom:10 }}>
            {(difficulties || []).map(d => (
              <TouchableOpacity
                key={d.id}
                onPress={() => setSelectedDifficulty(prev => prev === d.id ? null : d.id)}
                style={{
                  padding:8,
                  margin:6,
                  borderRadius:8,
                  backgroundColor: selectedDifficulty === d.id ? colors.buttonActive : colors.card
                }}
              >
                <AppText>{d.name}</AppText>
              </TouchableOpacity>
            ))}
          </View>
      </ScrollView>
    </View>
  );
}


########## KONIEC PLIKU: frontend\app\random\daily\index.tsx ##########



########## START PLIK: frontend\app\random\result.tsx ##########

import React, { useRef, useState, useEffect } from "react";
import { View, TouchableOpacity, Alert, Animated, ActivityIndicator } from "react-native";
import AppText from "../../components/AppText";
import { useRouter, useLocalSearchParams } from "expo-router";
import { colors } from "../../constants/theme";
import { api } from "../api/apiClient";
import RandomResultCard from "../../components/RandomResultCard";


export default function RandomResultScreen(){
  const { item, source, categoryId } = useLocalSearchParams() as any;
  const router = useRouter();

  const [currentItem, setCurrentItem] = useState(item ? JSON.parse(item) : null);
  const [assigning, setAssigning] = useState(false);
  const [assigned, setAssigned] = useState(false);
  const slideAnim = useRef(new Animated.Value(0)).current; 

  useEffect(() => {
    if (source === "challenge" && currentItem && !assigned && !assigning) {
      (async () => {
        setAssigning(true);
        try {
          await api.post("/challenges/assign/", { challenge: currentItem.id });
          setAssigned(true);
        } catch (e: any) {
          const err = e.response?.data?.detail || e.response?.data || e.message || e;
          Alert.alert("Error", typeof err === "string" ? err : JSON.stringify(err));
        } finally {
          setAssigning(false);
        }
      })();
    }
  }, [source, currentItem]);

  useEffect(() => {
    if (!currentItem) {
      router.replace("/(tabs)/RandomHomeScreen");
    }
  }, [currentItem]);


  const slideTodo = (nextItem: any) => {
    Animated.timing(slideAnim, { toValue: -50, duration: 250, useNativeDriver: true }).start(() => {
      setCurrentItem(nextItem);
      slideAnim.setValue(50);
      Animated.timing(slideAnim, { toValue: 0, duration: 250, useNativeDriver: true }).start();
    });
  };

  const onReroll = async () => {
    try {
      const res = await api.get("/todos/tasks/", { params: { category_id: categoryId }});
      const arr = res.data.filter((t:any) => !t.is_completed);
      if (!arr.length) { Alert.alert("Empty List", "No todos."); return; }
      const next = arr[Math.floor(Math.random() * arr.length)];
      slideTodo(next);
    } catch (e) { Alert.alert("Error", "Try again."); }
  };

  if (!currentItem) return null;

  const todoCard = (
    <RandomResultCard
      title={currentItem.content}
      animatedStyle={{
        transform: [{ translateY: slideAnim }],
      }}
    />
  );


  const goToActive = () => {
    if (!currentItem) return router.replace("/(tabs)/RandomHomeScreen");
    const dest = currentItem.type?.name === "daily" ? "/random/daily/active" : "/random/weekly/active";
    router.replace(dest);
  };

  return (
    <View style={{ flex:1, padding:18,  justifyContent:"center" }}>
      {source === "challenge" && (
        <>
          <RandomResultCard
              title={currentItem.title}
              description={currentItem.description}
            />


          {assigning && (
            <View style={{ marginTop:12, alignItems:"center" }}>
              <ActivityIndicator color={colors.buttonActive} />
              <AppText style={{ marginTop:8 }}>Assigning...</AppText>
            </View>
          )}

          {!assigning && (
            <TouchableOpacity onPress={goToActive} style={{ backgroundColor: colors.card, padding:14, borderRadius:10, marginTop:12 }}>
              <AppText style={{ textAlign: "center" }}>OK</AppText>
            </TouchableOpacity>
          )}
        </>
      )}

      {source === "todo" && (
        <>
          {todoCard}
          <TouchableOpacity onPress={() => router.replace("/(tabs)/RandomHomeScreen")} style={{ backgroundColor: colors.card, padding:14, borderRadius:10, marginBottom:12 }}>
            <AppText style={{ textAlign: "center" }}>OK</AppText>
          </TouchableOpacity>
          <TouchableOpacity onPress={onReroll} style={{ backgroundColor: colors.buttonActive, padding:14, borderRadius:10, marginBottom:12 }}>
            <AppText style={{ textAlign: "center", color:"#fff" }}>Reroll</AppText>
          </TouchableOpacity>
          <TouchableOpacity onPress={() => router.replace("/random/todo")} style={{ backgroundColor: colors.card, padding:14, borderRadius:10 }}>
            <AppText style={{ textAlign: "center" }}>Change category</AppText>
          </TouchableOpacity>
        </>
      )}
    </View>
  );
}


########## KONIEC PLIKU: frontend\app\random\result.tsx ##########



########## START PLIK: frontend\app\random\spin.tsx ##########

import React, { useEffect, useState } from "react";
import { View, StyleSheet } from "react-native";
import { colors } from "../../constants/theme";
import AppText from "../../components/AppText";

export default function RandomSpin({ items, onFinish }: { items: string[]; onFinish: (pickedIndex:number)=>void }) {
  const [index, setIndex] = useState(0);
  useEffect(() => {
    let ticks = 0;
    const interval = setInterval(() => {
      setIndex(i => (i + 1) % items.length);
      ticks++;
      if (ticks >= 12) {
        clearInterval(interval);
        const picked = Math.floor(Math.random() * items.length);
        onFinish(picked);
      }
    }, 50);
    return () => clearInterval(interval);
  }, []);

  return (
    <View style={styles.container}>
      <View style={styles.card}>
        <AppText style={styles.text}>{items[index]}</AppText>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { alignItems: "center", justifyContent: "center", flex: 1 },
  card: {
    padding: 28,
    borderRadius: 16,
    borderWidth: 2,
    borderColor: colors.light,
    backgroundColor: colors.card,
    maxWidth: "90%",
  },
  text: { fontSize: 22, fontWeight: "800", textAlign: "center" },
});


########## KONIEC PLIKU: frontend\app\random\spin.tsx ##########



########## START PLIK: frontend\app\random\todo\index.tsx ##########

import React, { useEffect, useState } from "react";
import { View, TouchableOpacity, ScrollView, Alert } from "react-native";
import AppText from "../../../components/AppText";
import { colors } from "../../../constants/theme";
import { useRouter } from "expo-router";
import { useTodoStore } from "../../stores/useTodoStore";
import RandomSpin from "../spin";

export default function TodoPickScreen() {
  const router = useRouter();

  const {
    categories,
    loadCategories,
    fetchRandomTask,
    hasUncompletedTasksInSelectedCategory,
    checkCategoryHasUncompletedTasks,
  } = useTodoStore();

  const [selectedCategory, setSelectedCategory] = useState<number | null>(null);
  const [spinning, setSpinning] = useState(false);
  const [spinItems, setSpinItems] = useState<string[]>([]);

  useEffect(() => {
    loadCategories();
  }, []);

  useEffect(() => {
    if (!categories.length) return;
    if (selectedCategory === null) {
      setSelectedCategory(categories[0].id);
    }
  }, [categories]);

  useEffect(() => {
    if (selectedCategory !== null) {
      checkCategoryHasUncompletedTasks(selectedCategory);
    }
  }, [selectedCategory]);

  const onLosuj = async () => {
    if (!selectedCategory) {
      Alert.alert("Choose a category");
      return;
    }

    if (hasUncompletedTasksInSelectedCategory === false) {
      Alert.alert("No tasks in this category.");
      return;
    }

    setSpinning(true);
    setSpinItems(["...", "Randomizing", "Searching", "Wait", "OK"]);

    const picked = await fetchRandomTask(selectedCategory);

    if (!picked) {
      setSpinning(false);
      Alert.alert("No tasks in this category.");
      return;
    }

    setTimeout(() => {
      setSpinning(false);
      router.push({
        pathname: "/random/result",
        params: {
          item: JSON.stringify(picked),
          source: "todo",
          categoryId: String(selectedCategory),
        },
      });
    }, 600);
  };

  if (spinning) {
    return (
      <RandomSpin
        items={spinItems.length ? spinItems : ["..."]}
        onFinish={() => {}}
      />
    );
  }

  const randomDisabled = hasUncompletedTasksInSelectedCategory === false;

  return (
    <View style={{ flex: 1, backgroundColor: colors.background }}>
      <ScrollView
        contentContainerStyle={{
          flexGrow: 1,
          justifyContent: "center",
          alignItems: "center",
          padding: 16,
        }}
        showsVerticalScrollIndicator={false}
      >
        <TouchableOpacity
          disabled={randomDisabled}
          onPress={onLosuj}
          style={{
            backgroundColor: randomDisabled
              ? colors.card
              : colors.buttonActive,
            padding: 16,
            borderRadius: 10,
            marginBottom: 8,
            width: "80%",
            alignItems: "center",
            opacity: randomDisabled ? 0.6 : 1,
          }}
        >
          <AppText style={{ color: "#fff", fontWeight: "bold" }}>
            Randomize!
          </AppText>
        </TouchableOpacity>

        {hasUncompletedTasksInSelectedCategory === false && (
          <AppText style={{ marginBottom: 12, color: "#999" }}>
            No tasks in this category
          </AppText>
        )}

        <AppText style={{ marginBottom: 8 }}>Choose a category:</AppText>

        <View
          style={{
            flexDirection: "row",
            flexWrap: "wrap",
            justifyContent: "center",
          }}
        >
          {categories.map((c) => (
            <TouchableOpacity
              key={c.id}
              onPress={() => setSelectedCategory(c.id)}
              style={{
                padding: 8,
                margin: 6,
                borderRadius: 8,
                backgroundColor:
                  selectedCategory === c.id
                    ? colors.buttonActive
                    : colors.card,
              }}
            >
              <AppText>{c.name}</AppText>
            </TouchableOpacity>
          ))}
        </View>
      </ScrollView>
    </View>
  );
}


########## KONIEC PLIKU: frontend\app\random\todo\index.tsx ##########



########## START PLIK: frontend\app\random\weekly\active.tsx ##########

import React, { useEffect, useState } from "react";
import { View, TouchableOpacity, Alert, ActivityIndicator } from "react-native";
import AppText from "../../../components/AppText";
import { useChallengeStore } from "../../stores/useChallengeStore";
import { colors } from "../../../constants/theme";
import { useRouter } from "expo-router";
import { useModuleSettingsStore } from "../../stores/useModuleSettingsStore";
import { useGamificationStore } from "../../stores/useGamificationStore";

export default function WeeklyActiveScreen() {
  const router = useRouter();
  const { fetchActive, activeWeekly, discardUserChallenge, completeUserChallenge } = useChallengeStore();
  const [loading, setLoading] = useState(true);

  const { modules } = useModuleSettingsStore();
  const gamificationOn = modules?.gamification;

  useEffect(() => {
    const load = async () => {
      await fetchActive();
      setLoading(false);
    };
    load();
  }, []);

  useEffect(() => {
    if (!loading && (!activeWeekly || activeWeekly.length === 0)) {
      router.replace("/random/weekly");
    }
  }, [loading, activeWeekly]);

  const tryAnother = async () => {
    try {
      await discardUserChallenge(activeChallenge.id);
      router.replace("/random/weekly");
    } catch {
      Alert.alert("Error", "Could not discard the challenge");
    }
  };

  const onComplete = async () => {
    const res = await completeUserChallenge(activeChallenge.id);
    if (!res) return Alert.alert("Error", "Could not complete the challenge");
    
    if (gamificationOn) {
      useGamificationStore.getState().applyXpResult(res);
    }

    router.replace("/(tabs)/RandomHomeScreen");
  
  };

  if (loading) {
    return <ActivityIndicator />
  }

  if (!activeWeekly || activeWeekly.length === 0) {
    return null;
  }

  const activeChallenge = activeWeekly[0];
  const challenge = activeChallenge.challenge;
  const days = activeChallenge.progress_days ?? 1;
  

  return (
    <View style={{ flex: 1, padding: 24, backgroundColor: colors.background, justifyContent: "center" }}>
        <AppText style={{ fontWeight: "bold", fontSize: 14, marginBottom: 12, color: colors.light, fontStyle: "italic" }}>
           You have an active weekly challenge!
      </AppText>
      <AppText style={{ fontSize: 20, fontWeight: "700", marginBottom: 6 , lineHeight: 24, paddingBottom: 2 }}>{challenge?.title}</AppText>
      <AppText style={{ marginBottom: 18, marginTop: 5 }}>{challenge?.description}</AppText>

      <View
        style={{
          height: 10,
          backgroundColor: colors.card,
          borderRadius: 6,
          overflow: "hidden",
          marginBottom: 8,
        }}
      >
        <View
          style={{
            width: `${(days / 7) * 100}%`,
            height: 10,
            backgroundColor: colors.buttonActive,
          }}
        />
      </View>

      <AppText style={{ marginBottom: 14 }}>
        {days}/7 days
      </AppText>


      <TouchableOpacity onPress={tryAnother} style={{ backgroundColor: colors.card, padding: 12, borderRadius: 10, marginBottom: 10 }}>
        <AppText style={{ textAlign: "center"}}>
          Try another
          {gamificationOn ? " (no XP)" : ""}
        </AppText>

      </TouchableOpacity>

      <TouchableOpacity onPress={onComplete} style={{ backgroundColor: colors.buttonActive, padding: 12, borderRadius: 10, marginBottom: 10 }}>
        <AppText style={{textAlign: "center", color: "#fff", fontWeight: "bold" }}>Completed</AppText>
      </TouchableOpacity>

      <TouchableOpacity onPress={() => router.replace("/(tabs)/RandomHomeScreen")} style={{ backgroundColor: colors.card, padding: 12, borderRadius: 10 }}>
        <AppText style={{ textAlign: "center", fontWeight: "bold" }}>Go back</AppText>
      </TouchableOpacity>
    </View>
  );
}




########## KONIEC PLIKU: frontend\app\random\weekly\active.tsx ##########



########## START PLIK: frontend\app\random\weekly\index.tsx ##########

import React, { useEffect, useState } from "react";
import { View, TouchableOpacity, ScrollView, Alert } from "react-native";
import AppText from "../../../components/AppText";
import { useChallengeStore } from "../../stores/useChallengeStore";
import { useRouter } from "expo-router";
import { colors } from "../../../constants/theme";
import RandomSpin from "../spin";

export default function WeeklyPickScreen() {
  const router = useRouter();
  const {
    loadTags,
    tags,
    fetchRandomChallenge,
    loadDifficulties,
    difficulties,
  } = useChallengeStore();

  const [selectedTags, setSelectedTags] = useState<number[]>([]);
  const [selectedDifficulty, setSelectedDifficulty] = useState<number | null>(null);
  const [spinning, setSpinning] = useState(false);
  const [spinItems, setSpinItems] = useState<string[]>([]);
  const [hasAvailableChallenge, setHasAvailableChallenge] = useState<boolean | null>(null);
  
  useEffect(() => {
    loadTags();
    if (typeof loadDifficulties === "function") loadDifficulties();
  }, []);

  useEffect(() => {
    const check = async () => {
      if (selectedTags.length === 0 && selectedDifficulty === null) {
        setHasAvailableChallenge(true);
        return;
      }

      const test = await fetchRandomChallenge(
        "weekly",
        selectedTags,
        selectedDifficulty
      );

      setHasAvailableChallenge(!!test);
    };

    check();
  }, [selectedTags, selectedDifficulty]);


  const toggleTag = (id: number) =>
    setSelectedTags((prev) =>
      prev.includes(id) ? prev.filter((x) => x !== id) : [...prev, id]
    );

  const onLosuj = async () => {
    if (!tags.length) {
      Alert.alert("No tags.");
      return;
    }

    let picked = null;

    const hasTags = selectedTags.length > 0;
    const hasDifficulty = selectedDifficulty !== null;

    if (hasTags) {
      picked = await fetchRandomChallenge(
        "weekly",
        selectedTags,
        selectedDifficulty
      );

      if (!picked) {
        picked = await fetchRandomChallenge("weekly", selectedTags, null);
      }

    } else if (hasDifficulty) {
      picked = await fetchRandomChallenge("weekly", [], selectedDifficulty);
    }

    if (!picked) {
      Alert.alert(
        "No matching challenge",
        "No challenge matches the selected filters."
      );
      return;
    }

    setSpinItems(["...", "Randomizing", "Searching", "Wait", "OK"]);
    setSpinning(true);

    setTimeout(() => {
      setSpinning(false);
      router.push({
        pathname: "/random/result",
        params: {
          item: JSON.stringify(picked),
          source: "challenge",
        },
      });
    }, 600);
  };


  if (spinning)
    return (
      <RandomSpin
        items={spinItems.length ? spinItems : ["..."]}
        onFinish={() => {}}
      />
    );

  const randomDisabled = hasAvailableChallenge === false;  

  return (
    <View style={{ flex: 1, backgroundColor: colors.background }}>
      <ScrollView
        contentContainerStyle={{
          flexGrow: 1,
          justifyContent: "center",
          alignItems: "center",
          padding: 16,
        }}
        showsVerticalScrollIndicator={false}
      >
        <TouchableOpacity
          disabled={randomDisabled}
          onPress={onLosuj}
          style={{
            backgroundColor: randomDisabled
              ? colors.card
              : colors.buttonActive,
            padding: 16,
            borderRadius: 10,
            marginBottom: 12,
            width: "80%",
            alignItems: "center",
            opacity: randomDisabled ? 0.6 : 1,
          }}
        >
          <AppText style={{ color: "#fff", fontWeight: "bold" }}>
            Randomize!
          </AppText>
        </TouchableOpacity>

        {hasAvailableChallenge === false && (
          <AppText style={{ marginBottom: 12, color: "#999" }}>
            No challenges match the selected filters
          </AppText>
        )}

        <AppText style={{ marginBottom: 8 }}>Filter by tags:</AppText>
        <View
          style={{
            flexDirection: "row",
            flexWrap: "wrap",
            justifyContent: "center",
            alignItems: "center",
          }}
        >
          {tags.map((t) => (
            <TouchableOpacity
              key={t.id}
              onPress={() => toggleTag(t.id)}
              style={{
                padding: 8,
                margin: 6,
                borderRadius: 8,
                backgroundColor: selectedTags.includes(t.id)
                  ? colors.buttonActive
                  : colors.card,
              }}
            >
              <AppText>{t.name}</AppText>
            </TouchableOpacity>
          ))}
        </View>

        <AppText style={{ marginBottom: 8 }}>Filter by difficulty:</AppText>
        <View
          style={{
            flexDirection: "row",
            flexWrap: "wrap",
            justifyContent: "center",
            alignItems: "center",
            marginBottom: 10,
          }}
        >
          {(difficulties || []).map((d) => (
            <TouchableOpacity
              key={d.id}
              onPress={() =>
                setSelectedDifficulty((prev) =>
                  prev === d.id ? null : d.id
                )
              }
              style={{
                padding: 8,
                margin: 6,
                borderRadius: 8,
                backgroundColor:
                  selectedDifficulty === d.id
                    ? colors.buttonActive
                    : colors.card,
              }}
            >
              <AppText>{d.name}</AppText>
            </TouchableOpacity>
          ))}
        </View>
      </ScrollView>
    </View>
  );
}


########## KONIEC PLIKU: frontend\app\random\weekly\index.tsx ##########



########## START PLIK: frontend\app\stores\useChallengeStore.ts ##########

import { create } from "zustand";
import { api } from "../api/apiClient";
import type { XpResult } from "./useGamificationStore";

export interface ChallengeTag {
  id: number;
  name: string;
}

export interface ChallengeType {
  id: number;
  name: "daily" | "weekly";
}

export interface DifficultyType {
  id: number;
  name: string;
}

export interface Challenge {
  id: number;
  title: string;
  description: string;
  type: ChallengeType;
  difficulty: DifficultyType;
  tags: ChallengeTag[];
}

export interface UserChallenge {
  id: number;
  challenge: Challenge;
  start_date: string;
  challenge_type: ChallengeType;
  weekly_deadline?: string;
  progress_days?: number;
  is_completed: boolean;
}

interface ChallengeStore {
  challenges: Challenge[];
  tags: ChallengeTag[];
  difficulties: DifficultyType[];

  activeDaily: UserChallenge | null;
  activeWeekly: UserChallenge[];

  loading: {
    list: boolean;
    meta: boolean;
    saving: boolean;
  };

  selectedType: "daily" | "weekly";
  setSelectedType: (t: "daily" | "weekly") => void;

  loadChallenges: () => Promise<void>;
  loadTags: () => Promise<void>;
  loadDifficulties: () => Promise<DifficultyType[]>;
  loadTypes: () => Promise<ChallengeType[]>;
  fetchActive: () => Promise<void>;

  fetchRandomChallenge: (
    type: "daily" | "weekly",
    tagIds?: number[],
    difficultyId?: number | null
  ) => Promise<Challenge | null>;

  assignChallenge: (challengeId: number) => Promise<UserChallenge | null>;
  discardUserChallenge: (id: number) => Promise<void>;
  completeUserChallenge: (id: number) => Promise<XpResult | null>;

  getChallengeById: (id: number) => Promise<Challenge | null>;
  createChallenge: (payload: any) => Promise<void>;
  updateChallenge: (id: number, payload: any) => Promise<void>;
  deleteChallenge: (id: number) => Promise<void>;

  getTagById: (id: number) => Promise<ChallengeTag | null>;
  createTag: (payload: { name: string }) => Promise<void>;
  updateTag: (id: number, payload: { name: string }) => Promise<void>;
  deleteTag: (id: number) => Promise<void>;
}


export const useChallengeStore = create<ChallengeStore>((set, get) => ({
  challenges: [],
  tags: [],
  difficulties: [],
  activeDaily: null,
  activeWeekly: [],
  selectedType: "daily",

  loading: {
    list: false,
    meta: false,
    saving: false,
  },

  setSelectedType: (t) => set({ selectedType: t }),

  loadChallenges: async () => {
    set((s) => ({ loading: { ...s.loading, list: true } }));
    try {
      const res = await api.get<Challenge[]>("/challenges/");
      set({ challenges: res.data });
    } catch (e) {
      console.error("loadChallenges", e);
    } finally {
      set((s) => ({ loading: { ...s.loading, list: false } }));
    }
  },

  loadTags: async () => {
    set((s) => ({ loading: { ...s.loading, meta: true } }));
    try {
      const res = await api.get<ChallengeTag[]>("/challenges/tags/");
      set({ tags: res.data });
    } catch (e) {
      console.error("loadTags", e);
    } finally {
      set((s) => ({ loading: { ...s.loading, meta: false } }));
    }
  },

  loadDifficulties: async () => {
    set((s) => ({ loading: { ...s.loading, meta: true } }));
    try {
      const res = await api.get<DifficultyType[]>("/common/difficulties/");
      set({ difficulties: res.data });
      return res.data;
    } catch (e) {
      console.error("loadDifficulties", e);
      return [];
    } finally {
      set((s) => ({ loading: { ...s.loading, meta: false } }));
    }
  },

  loadTypes: async () => {
    try {
      const res = await api.get<ChallengeType[]>("/challenges/types/");
      return res.data;
    } catch (e) {
      console.error("loadTypes", e);
      return [];
    }
  },

  fetchActive: async () => {
    set((s) => ({ loading: { ...s.loading, list: true } }));
    try {
      const res = await api.get("/challenges/active/");
      set({
        activeDaily: res.data.daily || null,
        activeWeekly: res.data.weekly || [],
      });
    } catch (e) {
      console.error("fetchActive", e);
    } finally {
      set((s) => ({ loading: { ...s.loading, list: false } }));
    }
  },


  fetchRandomChallenge: async (type, tagIds = [], difficultyId = null) => {
    try {
      const params: any = { type };
      if (tagIds.length) params.tags = tagIds.join(",");
      if (difficultyId) params.difficulty_id = difficultyId;

      const res = await api.get<Challenge>("/challenges/random/", { params });
      return res.data;
    } catch (e: any) {
      if (e.response?.status === 404) return null;
      console.warn("fetchRandomChallenge", e);
      return null;
    }
  },

  assignChallenge: async (challengeId) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      const res = await api.post<UserChallenge>("/challenges/assign/", {
        challenge: challengeId,
      });
      await Promise.all([get().loadChallenges(), get().fetchActive()]);
      return res.data;
    } catch (e) {
      console.error("assignChallenge", e);
      return null;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  discardUserChallenge: async (id) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.post(`/challenges/user-challenges/${id}/discard/`);
      await Promise.all([get().loadChallenges(), get().fetchActive()]);
    } catch (e) {
      console.error("discardUserChallenge", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  completeUserChallenge: async (id) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      const res = await api.post<XpResult>(
        `/challenges/user-challenges/${id}/complete/`
      );
      await Promise.all([get().loadChallenges(), get().fetchActive()]);
      return res.data;
    } catch (e) {
      console.error("completeUserChallenge", e);
      return null;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  getChallengeById: async (id) => {
    try {
      const res = await api.get(`/challenges/${id}/`);
      return res.data;
    } catch (e) {
      console.error("getChallengeById", e);
      return null;
    }
  },

  createChallenge: async (payload) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.post("/challenges/", payload);
      await get().loadChallenges();
    } catch (e) {
      console.error("createChallenge", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  updateChallenge: async (id, payload) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.patch(`/challenges/${id}/`, payload);
      await get().loadChallenges();
    } catch (e) {
      console.error("updateChallenge", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  deleteChallenge: async (id) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.delete(`/challenges/${id}/`);
      await get().loadChallenges();
    } catch (e) {
      console.error("deleteChallenge", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },
  getTagById: async (id) => {
    try {
      const res = await api.get<ChallengeTag>(`/challenges/tags/${id}/`);
      return res.data;
    } catch (e) {
      console.error("getTagById", e);
      return null;
    }
  },

  createTag: async (payload) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.post("/challenges/tags/", payload);
      await get().loadTags();
    } catch (e) {
      console.error("createTag", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  updateTag: async (id, payload) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.patch(`/challenges/tags/${id}/`, payload);
      await get().loadTags();
    } catch (e) {
      console.error("updateTag", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  deleteTag: async (id) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.delete(`/challenges/tags/${id}/`);
      await get().loadTags();
    } catch (e) {
      console.error("deleteTag", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

}));


########## KONIEC PLIKU: frontend\app\stores\useChallengeStore.ts ##########



########## START PLIK: frontend\app\stores\useGamificationStore.ts ##########

import { create } from "zustand";
import { api } from "../api/apiClient";

export type XpResult = {
  xp_gained: number;
  total_xp: number;
  current_level: number;
};

type XpPopup = {
  xp: number;
  levelUp: boolean;
};

type GamificationState = {
  totalXp: number;
  currentLevel: number;
  xpMultiplier: number
  xpPopup: XpPopup | null;
  loading: boolean;

  fetchUser: () => Promise<void>;
  applyXpResult: (result: XpResult) => void;
  setXpMultiplier: (value: number) => Promise<void>;
  clearXpPopup: () => void;
};

export const useGamificationStore = create<GamificationState>((set, get) => ({
  totalXp: 0,
  currentLevel: 1,
  xpMultiplier: 1.0,
  xpPopup: null,
  loading: false,

  fetchUser: async () => {
    set({ loading: true });
    const res = await api.get("/gamification/me/");
    set({
      totalXp: res.data.total_xp,
      currentLevel: res.data.current_level,
      xpMultiplier: res.data.xp_multiplier,
      loading: false,
    });
  },


  applyXpResult: (result) => {
    const prevLevel = get().currentLevel;
    const levelUp = result.current_level > prevLevel;

    set({
      totalXp: result.total_xp,
      currentLevel: result.current_level,
      xpPopup: {
        xp: result.xp_gained,
        levelUp,
      },
    });
  },

  setXpMultiplier: async (value: number) => {
  await api.patch("/gamification/me/", { xp_multiplier: value });
  set({ xpMultiplier: value });
  },

  clearXpPopup: () => {
    set({ xpPopup: null });
  },

}));


########## KONIEC PLIKU: frontend\app\stores\useGamificationStore.ts ##########



########## START PLIK: frontend\app\stores\useGoalStore.ts ##########

import { create } from "zustand";
import { api } from "../api/apiClient";

export interface DifficultyType {
  id: number;
  name: string;
}

export interface GoalPeriod {
  id: number;
  name: string;
}

export interface Goal {
  id: number;
  title: string;
  description: string;
  motivation_reason?: string;
  period: GoalPeriod;
  difficulty: DifficultyType;
  is_completed: boolean;
  completed_at?: string | null;
}

interface GoalStore {
  goals: Goal[];
  periods: GoalPeriod[];

  currentPeriod?: string;

  loading: {
    list: boolean;
    periods: boolean;
    meta: boolean;
    saving: boolean;
  };

  loadPeriods: () => Promise<void>;
  loadGoals: (period?: string) => Promise<void>;
  loadDifficulties: () => Promise<DifficultyType[]>;

  createGoal: (payload: any) => Promise<boolean>;
  saveGoal: (id: number, payload: any) => Promise<boolean>;
  deleteGoal: (id: number) => Promise<boolean>;

  completeGoal: (id: number) => Promise<{
    xp_gained: number;
    total_xp: number;
    current_level: number;
  } | null>;

  pickRandomGoal: (period?: string) => Promise<Goal | null>;
  getGoalById: (id: number) => Promise<Goal | null>;

}

const initialState = {
  goals: [],
  periods: [],
  currentPeriod: undefined,
  loading: {
    list: false,
    periods: false,
    meta: false,
    saving: false,
  },
};

export const useGoalStore = create<GoalStore>((set, get) => ({
  ...initialState,

  loadPeriods: async () => {
    set((s) => ({ loading: { ...s.loading, periods: true } }));
    try {
      const res = await api.get<GoalPeriod[]>("/goals/periods/");
      set({ periods: res.data });
    } catch (e) {
      console.error("loadPeriods", e);
    } finally {
      set((s) => ({ loading: { ...s.loading, periods: false } }));
    }
  },

  loadGoals: async (period) => {
    set((s) => ({ loading: { ...s.loading, list: true } }));
    try {
      const url = period ? `/goals/?period=${period}` : "/goals/";
      const res = await api.get<Goal[]>(url);

      set({
        goals: res.data,
        currentPeriod: period,
      });
    } catch (e) {
      console.error("loadGoals", e);
    } finally {
      set((s) => ({ loading: { ...s.loading, list: false } }));
    }
  },


  loadDifficulties: async () => {
    set((s) => ({ loading: { ...s.loading, meta: true } }));
    try {
      const res = await api.get<DifficultyType[]>("/common/difficulties/");
      return res.data;
    } catch (e) {
      console.error("loadDifficulties", e);
      return [];
    } finally {
      set((s) => ({ loading: { ...s.loading, meta: false } }));
    }
  },

  createGoal: async (payload) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.post("/goals/", payload);
      await get().loadGoals(get().currentPeriod);
      return true;
    } catch (e) {
      console.error("createGoal", e);
      return false;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },


  saveGoal: async (id, payload) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.patch(`/goals/${id}/`, payload);
      await get().loadGoals(get().currentPeriod);
      return true;
    } catch (e) {
      console.error("saveGoal", e);
      return false;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },


  deleteGoal: async (id) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.delete(`/goals/${id}/`);
      await get().loadGoals(get().currentPeriod);
      return true;
    } catch (e) {
      console.error("deleteGoal", e);
      return false;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  completeGoal: async (id) => {
    try {
      const res = await api.post(`/goals/${id}/complete/`);
      return res.data;
    } catch (e) {
      console.error("completeGoal", e);
      return null;
    }
  },

  getGoalById: async (id) => {
    try {
      const res = await api.get(`/goals/${id}/`);
      return res.data;
    } catch (e) {
      console.error("getGoalById", e);
      return null;
    }
  },

  pickRandomGoal: async (period?: string) => {
    try {
      const url = period ? `/goals/random/?period=${period}` : "/goals/random/";
      const res = await api.get<Goal | null>(url);
      return res.data;
    } catch (e) {
      console.error("pickRandomGoal", e);
      return null;
    }
  },

}));


########## KONIEC PLIKU: frontend\app\stores\useGoalStore.ts ##########



########## START PLIK: frontend\app\stores\useHabitStore.ts ##########

import { create } from "zustand";
import { api } from "../api/apiClient";

export interface DifficultyType {
  id: number;
  name: string;
}

export interface HabitDay {
  date: string;
  status: number;
  xp_awarded?: boolean;
}

export interface Habit {
  id: number;
  title: string;
  description?: string;
  motivation_reason?: string;
  color?: string;
  difficulty: DifficultyType;
  is_active: boolean;
  created_at?: string;
  updated_at?: string;
  days?: HabitDay[];
}

interface ToggleDayResponse {
  xp_gained: number;
  total_xp: number;
  current_level: number;
  already_completed?: boolean;
}

export interface BestHabitStreak {
  habit_id: number | null;
  title: string | null;
  biggest_streak: number;
  current_streak: number;
}

export interface RandomHabitSummary {
  id: number;
  title: string;
  reason?: string;
  done: number;
  total: number;
}

interface HabitStore {
  habits: Habit[];
  currentMonth?: string;
  difficulties: DifficultyType[];
  biggestStreak: BestHabitStreak | null;

  loading: {
    list: boolean;
    meta: boolean;
    saving: boolean;
    streaks: boolean;
  };

  loadMonth: (
    month?: string,
    opts?: { silent?: boolean }
  ) => Promise<void>;

  loadDifficulties: () => Promise<DifficultyType[]>;
  fetchStreaks: () => Promise<BestHabitStreak | null>;

  createHabit: (payload: any) => Promise<void>;
  updateHabit: (id: number, payload: any) => Promise<void>;
  deleteHabit: (id: number) => Promise<void>;

  toggleDay: (
    habitId: number,
    date?: string,
    status?: number
  ) => Promise<ToggleDayResponse | null>;

  getHabitById: (id: number) => Promise<Habit | null>;
  pickRandomHabitSummary: () => Promise<RandomHabitSummary | null>;
}

const initialState = {
  habits: [],
  currentMonth: undefined,
  difficulties: [],
  biggestStreak: null,
  loading: {
    list: false,
    meta: false,
    saving: false,
    streaks: false,
  },
};

export const useHabitStore = create<HabitStore>((set, get) => ({
  ...initialState,

  loadMonth: async (
    month?: string,
    opts?: { silent?: boolean }
  ) => {
    const silent = opts?.silent === true;

    if (!silent) {
      set((s) => ({
        loading: { ...s.loading, list: true },
      }));
    }

    try {
      const url = month
        ? `/habits/month/?month=${month}`
        : `/habits/month/`;

      const res = await api.get(url);

      set({
        habits: res.data.habits || [],
        currentMonth: month,
      });
    } catch (e) {
      console.error("loadMonth", e);
    } finally {
      if (!silent) {
        set((s) => ({
          loading: { ...s.loading, list: false },
        }));
      }
    }
  },


  loadDifficulties: async () => {
    set((s) => ({ loading: { ...s.loading, meta: true } }));
    try {
      const res = await api.get<DifficultyType[]>("/common/difficulties/");
      set({ difficulties: res.data });
      return res.data;
    } catch (e) {
      console.error("loadDifficulties", e);
      return [];
    } finally {
      set((s) => ({ loading: { ...s.loading, meta: false } }));
    }
  },

  fetchStreaks: async () => {
    set((s) => ({ loading: { ...s.loading, streaks: true } }));
    try {
      const res = await api.get("/habits/streaks/");
      set({ biggestStreak: res.data });
      return res.data;
    } catch (e) {
      console.error("fetchStreaks", e);
      return null;
    } finally {
      set((s) => ({ loading: { ...s.loading, streaks: false } }));
    }
  },

  createHabit: async (payload) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.post("/habits/", payload);
      await get().loadMonth(get().currentMonth);
    } catch (e) {
      console.error("createHabit", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  updateHabit: async (id, payload) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.patch(`/habits/${id}/`, payload);
      await get().loadMonth(get().currentMonth);
    } catch (e) {
      console.error("updateHabit", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  deleteHabit: async (id) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.delete(`/habits/${id}/`);
      await get().loadMonth(get().currentMonth);
    } catch (e) {
      console.error("deleteHabit", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  toggleDay: async (habitId, date, status) => {
    try {
      const payload: any = {};
      if (date) payload.date = date;
      if (typeof status !== "undefined") payload.status = status;

      const res = await api.post(
        `/habits/${habitId}/toggle-day/`,
        payload
      );

      return res.data as ToggleDayResponse;
    } catch (e: any) {
      console.error("toggleDay", e.response?.data || e.message || e);
      return null;
    }
  },

  getHabitById: async (id) => {
    try {
      const res = await api.get(`/habits/${id}/`);
      return res.data;
    } catch (e) {
      console.error("getHabitById", e);
      return null;
    }
  },

  pickRandomHabitSummary: async (): Promise<RandomHabitSummary | null> => {
    try {
      const res = await api.get<RandomHabitSummary | null>("/habits/random/");
      return res.data ?? null;
    } catch (e) {
      console.error("pickRandomHabitSummary", e);
      return null;
    }
  },

}));


########## KONIEC PLIKU: frontend\app\stores\useHabitStore.ts ##########



########## START PLIK: frontend\app\stores\useModuleSettingsStore.ts ##########

import { create } from "zustand";
import { api } from "../api/apiClient";

export type ModuleKey =
  | "habits"
  | "challenges"
  | "todos"
  | "goals"
  | "random"
  | "gamification"
  | "notes";

export type DashboardTileKey =
  | "level_gamification"
  | "biggest_streak"
  | "random_habit"
  | "random_todo"
  | "goal_week"
  | "goal_month"
  | "goal_year"
  | "daily_challenge"
  | "weekly_challenge"
  | "random_note";

type DashboardTileSetting = {
  id: number;
  key: DashboardTileKey;
  name: string;
  is_enabled: boolean;
  module_dependency?: ModuleKey;
};

type ModuleSetting = {
  id: number;
  module: ModuleKey;
  is_enabled: boolean;
};

type ModuleStore = {
  modules: Record<ModuleKey, boolean> | null;
  raw: ModuleSetting[];
  dashboardTiles: DashboardTileSetting[];

  pendingModuleToggles: number[];

  fetchModules: () => Promise<void>;
  toggleModule: (id: number, value: boolean) => Promise<void>;
  toggleTile: (id: DashboardTileKey, value: boolean) => void;
};

export const useModuleSettingsStore = create<ModuleStore>((set, get) => ({
  modules: null,
  raw: [],
  dashboardTiles: [],
  pendingModuleToggles: [],

  fetchModules: async () => {
    if (get().modules) return;

    const res = await api.get("/settings/modules/");

    const modules: Record<ModuleKey, boolean> = {
      habits: false,
      challenges: false,
      todos: false,
      goals: false,
      random: false,
      gamification: false,
      notes: false,
    };

    res.data.forEach((m: ModuleSetting) => {
      modules[m.module] = m.is_enabled;
    });

    set({ modules, raw: res.data });

    try {
      const tRes = await api.get("/settings/dashboard-tiles/");
      set({ dashboardTiles: tRes.data });
    } catch (e) {
      console.warn("Can't load dashboard tiles:", e);
    }
  },

  toggleModule: async (id, value) => {
    const prevRaw = get().raw;
    const prevModules = get().modules;

    const changed = prevRaw.find((m) => m.id === id);

    const rawOptimistic = prevRaw.map((m) =>
      m.id === id ? { ...m, is_enabled: value } : m
    );

    const modulesOptimistic = { ...(prevModules as Record<ModuleKey, boolean>) };
    if (changed) modulesOptimistic[changed.module] = value;

    set({
      raw: rawOptimistic,
      modules: modulesOptimistic,
      pendingModuleToggles: [...get().pendingModuleToggles, id],
    });

    try {
      await api.patch(`/settings/modules/${id}/`, { is_enabled: value });

      const tRes = await api.get("/settings/dashboard-tiles/");
      set({ dashboardTiles: tRes.data });

      set({
        pendingModuleToggles: get().pendingModuleToggles.filter(
          (x) => x !== id
        ),
      });
    } catch (e) {

      set({
        raw: prevRaw,
        modules: prevModules,
        pendingModuleToggles: get().pendingModuleToggles.filter(
          (x) => x !== id
        ),
      });

      console.error("toggleModule failed", e);
    }
  },

  toggleTile: async (id: DashboardTileKey, value: boolean) => {
    const tile = get().dashboardTiles.find(
      (t: any) => t.key === id || t.id === id
    );

    if (!tile) return;

    try {
      await api.patch(`/settings/dashboard-tiles/${tile.id}/`, {
        is_enabled: value,
      });

      set({
        dashboardTiles: get().dashboardTiles.map((t: any) =>
          t.id === tile.id ? { ...t, is_enabled: value } : t
        ),
      });
    } catch (e) {
      console.error("toggleTile error", e);
    }
  },
}));


########## KONIEC PLIKU: frontend\app\stores\useModuleSettingsStore.ts ##########



########## START PLIK: frontend\app\stores\useMoodStore.ts ##########

import { create } from "zustand";
import { api } from "../api/apiClient";

export type MoodType =
  | "great"
  | "good"
  | "neutral"
  | "bad"
  | "terrible";

export type MoodEntry = {
  id: number;
  mood: MoodType;
  date: string;   // YYYY-MM-DD
  time: string;   // HH:MM:SS
  note: string;
};

type MoodState = {
  entries: MoodEntry[];
  fetchYear: (year: number) => Promise<void>;
  addMood: (data: Partial<MoodEntry>) => Promise<void>;
  updateMood: (id: number, data: Partial<MoodEntry>) => Promise<void>;
  deleteMood: (id: number) => Promise<void>;
};

export const useMoodStore = create<MoodState>((set, get) => ({
  entries: [],

  fetchYear: async (year) => {
    const res = await api.get(`/mood/?year=${year}`);
    set({ entries: res.data });
  },

    addMood: async (data) => {
    const res = await api.post("/mood/", data);

    set((state) => ({
        entries: [...state.entries, res.data],
    }));
    },

    updateMood: async (id, data) => {
    const res = await api.patch(`/mood/${id}/`, data);

    set((state) => ({
        entries: state.entries.map((e) =>
        e.id === id ? res.data : e
        ),
    }));
    },

  deleteMood: async (id) => {
    await api.delete(`/mood/${id}/`);
  },
}));

########## KONIEC PLIKU: frontend\app\stores\useMoodStore.ts ##########



########## START PLIK: frontend\app\stores\useNotesStore.ts ##########

import { create } from "zustand";
import { api } from "../api/apiClient";

interface Note {
  id: number;
  content: string;
}

interface NotesStore {
  randomNote: Note | null;
  loading: boolean;

  fetchRandomNote: () => Promise<void>;
  fetchById: (id: number) => Promise<Note | null>;

  createNote: (content: string) => Promise<void>;
  updateNote: (id: number, content: string) => Promise<void>;
  deleteNote: (id: number) => Promise<void>;
}

export const useNotesStore = create<NotesStore>((set) => ({
  randomNote: null,
  loading: false,

  fetchRandomNote: async () => {
    set({ loading: true });
    try {
      const res = await api.get("/notes/random/");
      set({ randomNote: res.data });
    } catch {
      set({ randomNote: null });
    } finally {
      set({ loading: false });
    }
  },

  fetchById: async (id: number) => {
    try {
      const res = await api.get(`/notes/${id}/`);
      return res.data;
    } catch {
      return null;
    }
  },

  createNote: async (content: string) => {
    await api.post("/notes/", { content });
    await useNotesStore.getState().fetchRandomNote();
  },

  updateNote: async (id: number, content: string) => {
    await api.patch(`/notes/${id}/`, { content });
    await useNotesStore.getState().fetchRandomNote();
  },

  deleteNote: async (id: number) => {
    await api.delete(`/notes/${id}/`);
    await useNotesStore.getState().fetchRandomNote();
  },
}));



########## KONIEC PLIKU: frontend\app\stores\useNotesStore.ts ##########



########## START PLIK: frontend\app\stores\useTodoStore.ts ##########

import { create } from "zustand";
import { api } from "../api/apiClient";

export interface DifficultyType {
  id: number;
  name: string;
}

export interface TodoCategory {
  id: number;
  name: string;
  color?: string;
  difficulty?: DifficultyType;
}

export interface TodoTask {
  id: number;
  content: string;
  custom_difficulty?: DifficultyType | null;
  category: TodoCategory;
  is_completed: boolean;
  created_at: string;
}

interface TodoStore {
  categories: TodoCategory[];
  tasks: TodoTask[];

  selectedCategoryId: number | null;
  hasUncompletedTasksInSelectedCategory: boolean | null;

  loading: {
    categories: boolean;
    tasks: boolean;
    saving: boolean;
    meta: boolean;
  };

  loadCategories: () => Promise<void>;
  loadTasks: (categoryId: number) => Promise<void>;
  loadDifficulties: () => Promise<DifficultyType[]>;

  createCategory: (payload: any) => Promise<void>;
  saveCategory: (id: number, payload: any) => Promise<void>;
  deleteCategory: (id: number) => Promise<void>;

  quickAddTask: (
    categoryId: number,
    content: string,
    customDifficultyId?: number | null
  ) => Promise<void>;

  updateTask: (
    taskId: number,
    payload: { content: string; custom_difficulty_id?: number | null }
  ) => Promise<void>;

  completeTask: (
    taskId: number
  ) => Promise<{ xp_gained: number; total_xp: number; current_level: number } | null>;

  deleteTask: (taskId: number) => Promise<void>;

  fetchRandomTask: (categoryId?: number) => Promise<TodoTask | null>;
  checkCategoryHasUncompletedTasks: (categoryId: number) => Promise<void>;
  getCategoryById: (id: number) => Promise<TodoCategory | null>;
  setSelectedCategoryId: (id: number | null) => void;

}

const initialState = {
  categories: [],
  tasks: [],
  selectedCategoryId: null,
  hasUncompletedTasksInSelectedCategory: null,
  loading: {
    categories: false,
    tasks: false,
    saving: false,
    meta: false,
  },
};

export const useTodoStore = create<TodoStore>((set, get) => ({
  ...initialState,

  loadCategories: async () => {
    set((s) => ({ loading: { ...s.loading, categories: true } }));
    try {
      const res = await api.get<TodoCategory[]>("/todos/categories/");
      set({ categories: res.data });
    } catch (e) {
      console.error("loadCategories", e);
    } finally {
      set((s) => ({ loading: { ...s.loading, categories: false } }));
    }
  },

  loadTasks: async (categoryId) => {
    if (!categoryId) return;

    set((s) => ({ loading: { ...s.loading, tasks: true } }));
    try {
      const res = await api.get<TodoTask[]>("/todos/tasks/", {
        params: { category_id: categoryId },
      });

      const hasUncompleted = res.data.some(t => !t.is_completed);

      set({
        tasks: res.data,
        hasUncompletedTasksInSelectedCategory: hasUncompleted,
      });
    } catch (e) {
      console.error("loadTasks", e);
      set({ hasUncompletedTasksInSelectedCategory: false });
    } finally {
      set((s) => ({ loading: { ...s.loading, tasks: false } }));
    }
  },

  loadDifficulties: async () => {
    set((s) => ({ loading: { ...s.loading, meta: true } }));
    try {
      const res = await api.get<DifficultyType[]>("/common/difficulties/");
      return res.data;
    } catch (e) {
      console.error("loadDifficulties", e);
      return [];
    } finally {
      set((s) => ({ loading: { ...s.loading, meta: false } }));
    }
  },

  createCategory: async (payload) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.post("/todos/categories/", payload);
      await get().loadCategories();
    } catch (e) {
      console.error("createCategory", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  saveCategory: async (id, payload) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.patch(`/todos/categories/${id}/`, payload);
      await get().loadCategories();
    } catch (e) {
      console.error("saveCategory", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  deleteCategory: async (id) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.delete(`/todos/categories/${id}/`);
      await get().loadCategories();
    } catch (e) {
      console.error("deleteCategory", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  quickAddTask: async (categoryId, content, customDifficultyId = null) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.post("/todos/tasks/", {
        category_id: categoryId,
        content,
        custom_difficulty_id: customDifficultyId,
      });
      await get().loadTasks(categoryId);
    } catch (e) {
      console.error("quickAddTask", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  updateTask: async (taskId, payload) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      await api.patch(`/todos/tasks/${taskId}/`, payload);
      const task = get().tasks.find((t) => t.id === taskId);
      if (task) await get().loadTasks(task.category.id);
    } catch (e) {
      console.error("updateTask", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  completeTask: async (taskId) => {
    try {
      const res = await api.post(`/todos/tasks/${taskId}/complete/`);
      const task = get().tasks.find((t) => t.id === taskId);
      if (task) await get().loadTasks(task.category.id);
      return res.data;
    } catch (e) {
      console.error("completeTask", e);
      return null;
    }
  },

  deleteTask: async (taskId) => {
    set((s) => ({ loading: { ...s.loading, saving: true } }));
    try {
      const task = get().tasks.find((t) => t.id === taskId);
      await api.delete(`/todos/tasks/${taskId}/`);
      if (task) await get().loadTasks(task.category.id);
    } catch (e) {
      console.error("deleteTask", e);
      throw e;
    } finally {
      set((s) => ({ loading: { ...s.loading, saving: false } }));
    }
  },

  fetchRandomTask: async (categoryId) => {
    try {
      const res = await api.get<TodoTask>("/todos/tasks/random/", {
        params: categoryId ? { category_id: categoryId } : {},
      });
      return res.data ?? null;
    } catch (e) {
      console.error("fetchRandomTask", e);
      return null;
    }
  },

  checkCategoryHasUncompletedTasks: async (categoryId) => {
    try {
      const res = await api.get<TodoTask[]>("/todos/tasks/", {
        params: { category_id: categoryId },
      });
      const hasUncompleted = res.data.some(t => !t.is_completed);
      set({ hasUncompletedTasksInSelectedCategory: hasUncompleted });
    } catch (e) {
      console.error("checkCategoryHasUncompletedTasks", e);
      set({ hasUncompletedTasksInSelectedCategory: false });
    }
  },

  getCategoryById: async (id) => {
    try {
      const res = await api.get<TodoCategory>(`/todos/categories/${id}/`);
      return res.data;
    } catch (e) {
      console.error("getCategoryById", e);
      return null;
    }
  },

  setSelectedCategoryId: (id) =>
    set({
      selectedCategoryId: id,
      tasks: [],
      hasUncompletedTasksInSelectedCategory: null,
    }),

}));


########## KONIEC PLIKU: frontend\app\stores\useTodoStore.ts ##########



########## START PLIK: frontend\utils\calcXpPreview.ts ##########

export function calcXpPreview({
  baseXp,
  moduleMultiplier,
  periodMultiplier = 1,
  xpMultiplier,
}: {
  baseXp: number;
  moduleMultiplier: number;
  periodMultiplier?: number;
  xpMultiplier: number;
}) {
  return Math.round(
    baseXp * moduleMultiplier * periodMultiplier * xpMultiplier
  );
}


########## KONIEC PLIKU: frontend\utils\calcXpPreview.ts ##########


